<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pipeline Performance Considerations - Practical MongoDB Aggregations</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="../favicon.svg">
        
        
        <link rel="shortcut icon" href="../favicon.png">
        
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        
        <link rel="stylesheet" href="../css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="../fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../cover-page.html">Practical MongoDB Aggregations</a></li><li class="chapter-item expanded affix "><a href="../credits.html">Credits</a></li><li class="chapter-item expanded "><a href="../intro/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../intro/history.html"><strong aria-hidden="true">1.1.</strong> History</a></li></ol></li><li class="chapter-item expanded "><a href="../guides/00-guides.html"><strong aria-hidden="true">2.</strong> Guiding Tips &amp; Principles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../guides/getting-started.html"><strong aria-hidden="true">2.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="../guides/getting-help.html"><strong aria-hidden="true">2.2.</strong> Getting Help</a></li><li class="chapter-item expanded "><a href="../guides/composibility.html"><strong aria-hidden="true">2.3.</strong> Embrace Composibility For Increased Productivity</a></li><li class="chapter-item expanded "><a href="../guides/project.html"><strong aria-hidden="true">2.4.</strong> To Project Or Not To Project, That Is The Question</a></li><li class="chapter-item expanded "><a href="../guides/explain.html"><strong aria-hidden="true">2.5.</strong> Using Explain Plans</a></li><li class="chapter-item expanded "><a href="../guides/performance.html" class="active"><strong aria-hidden="true">2.6.</strong> Pipeline Performance Considerations</a></li><li class="chapter-item expanded "><a href="../guides/expressions.html"><strong aria-hidden="true">2.7.</strong> Can Expressions By Used Everywhere?</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/examples.html"><strong aria-hidden="true">3.</strong> Aggregations By Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/simple-examples/00-simple-examples.html"><strong aria-hidden="true">3.1.</strong> Simple Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/simple-examples/filtered-top-subset.html"><strong aria-hidden="true">3.1.1.</strong> Filtered Top Subset</a></li><li class="chapter-item expanded "><a href="../examples/simple-examples/group-and-total.html"><strong aria-hidden="true">3.1.2.</strong> Group &amp; Total</a></li><li class="chapter-item expanded "><a href="../examples/simple-examples/unpack-array-group-differently.html"><strong aria-hidden="true">3.1.3.</strong> Unpack Arrays &amp; Group Differently</a></li><li class="chapter-item expanded "><a href="../examples/simple-examples/one-to-one-join.html"><strong aria-hidden="true">3.1.4.</strong> One-to-One Join</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/moderate-examples/00-moderate-examples.html"><strong aria-hidden="true">3.2.</strong> Moderate Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/moderate-examples/multi-one-to-many.html"><strong aria-hidden="true">3.2.1.</strong> Multi-Field Join &amp; One-to-Many</a></li><li class="chapter-item expanded "><a href="../examples/moderate-examples/mask-sensitive-fields.html"><strong aria-hidden="true">3.2.2.</strong> Mask Sensitive Fields</a></li><li class="chapter-item expanded "><a href="../examples/moderate-examples/largest-graph-network.html"><strong aria-hidden="true">3.2.3.</strong> Largest Graph Network</a></li></ol></li><li class="chapter-item expanded "><a href="../examples/intricate-examples/00-intricate-examples.html"><strong aria-hidden="true">3.3.</strong> Intricate Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../examples/intricate-examples/restricted-view.html"><strong aria-hidden="true">3.3.1.</strong> Restricted View</a></li><li class="chapter-item expanded "><a href="../examples/intricate-examples/convert-incomplete-dates.html"><strong aria-hidden="true">3.3.2.</strong> Convert Incomplete Date Strings</a></li></ol></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Practical MongoDB Aggregations</h1>

                    <div class="right-buttons">
                        
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pipeline-performance-considerations"><a class="header" href="#pipeline-performance-considerations">Pipeline Performance Considerations</a></h1>
<p>As with any programming language, premature optimisation when prototyping an aggregation pipeline will often lead to an over-complicated solution which doesn't actually address the specific performance challenges that manifest. As described in the previous chapter, <a href="./explain.html">Using Explain Plans</a>, the tool of choice to identify opportunities for effective optimisation is the aggregation's <em>explain plan</em>. This is typically used during the final stages of a pipeline's development, once the pipeline is functionally correct and producing the right data results.</p>
<p>However, being aware of some guiding principles regarding performance can still be useful whilst prototyping a pipeline. Importantly, such guiding principles are likely to be invaluable once the aggregation's explain plan is analysed and if it shows that the current pipeline is sub-optimal.</p>
<p>With this in mind, this chapter outlines three potentially 'big-ticket' considerations to make when creating or tuning an aggregation pipeline, which, when aggregating very large source data-sets, can often be the difference between an aggregation returning in milliseconds or a few seconds, versus returning in minutes, hours or even longer.</p>
<h2 id="be-cognizant-of-streaming-vs-blocking-stages-ordering"><a class="header" href="#be-cognizant-of-streaming-vs-blocking-stages-ordering">Be Cognizant Of Streaming Vs Blocking Stages Ordering</a></h2>
<p>When executing an aggregation pipeline, the database engine pulls batches of records at a time from the initial query cursor that has been generated against the source collection. The database engine then attempts to stream each batch through the stages of the aggregation pipeline. For most types of pipeline stages, refereed to as <em>streaming stages</em>, a batch of records processed by a stage will then be streamed on to the next stage, without the stage trying to wait for all the other record batches to first arrive. However, two types of stages do have to block and wait for all batches of records outputted from a previous stage to arrive and accumulate together at that stage. These are referred to as <em>blocking stages</em> and specifically the two types of stages that block are:</p>
<ul>
<li><code>$sort</code></li>
<li><code>$group</code> *</li>
</ul>
<blockquote>
<p>* <em>actually when stating <code>$group</code>, this also includes other less frequently used 'grouping' stages too, specifically:</em><code>$bucket</code>, <code>$bucketAuto</code>, <code>$count</code> &amp; <code>$sortByCount</code></p>
</blockquote>
<p>The diagram below highlights the nature of streaming and blocking stages, where streaming stages allow batches to be processed and then passed through without waiting, whereas blocking stages wait for the whole of its input data set to arrive and accumulate before the stage then processes all this data together.</p>
<p><img src="./pics/streaming-blocking.png" alt="Streaming Vs Blocking" /></p>
<p>It is of course necessary for both <code>$sort</code> and <code>$group</code> to be blocking stages, as illustrated by the following examples:</p>
<ol>
<li>
<p><strong>$sort blocking requirement example</strong>: Take an example of a pipeline needing to sort <em>people</em> in ascending order of <em>age</em>. There would be a problem if the stage didn't wait to see the whole input data-set, and instead just sorted the <em>people</em> in one batch at a time before passing that sorted batch of <em>people</em> on to the next stage or final result, without waiting. The next batch of people records to arrive at the <code>$sort</code> stage could well contain one or more people who are younger than the sorted ones already passed through. In the final result, these records should have appeared earlier in the final result set, but it would be too late.</p>
</li>
<li>
<p><strong>$group blocking requirement example</strong>: Take an example of a pipeline needing to group <em>employees</em> by one of the two <em>work departments</em> they belong to (either <em>sales</em> or <em>manufacturing</em>), and in the first batch of records arriving at the <code>$group</code> stage, each of the two departments groups and embeds a few employees each. There would be a problem if the <code>$group</code> stage didn't wait to see the other batches and instead immediately streamed the current processed departments memberships on to the next stage or final result. The grouped department memberships output by the pipeline to the client application would be incomplete because later batches of people records are yet to still to arrive at the earlier <code>$group</code> stage.</p>
</li>
</ol>
<p>These necessary blocking stages don't just reduce aggregation execution time directly, by virtue of the fact that streaming is blocked. There is also another dimension to the performance impact incurred, related to memory consumption, which can ultimately reduce throughput and increase latency dramatically:</p>
<ol>
<li>
<p><strong>$sort memory consumption</strong>: For a <code>$sort</code> stage to see all the input records at once, the host server must typically have enough capacity to hold the whole input data set in memory, which will be heavily dependent on the nature of the source data-set and how much the earlier stages of the pipeline have first reduced the data-set size. Also, multiple instances of the aggregation pipeline may be in-flight at any one time, in addition to other types of executing aggregations and database workloads, all competing for the same memory resources. If the source data-set is many gigabytes or even terabytes in size and it has not been possible for earlier stages to significantly reduce this size, it is unlikely that the host machines will have sufficient memory to support the pipeline and its blocking <code>$sort</code> stage. As a result, MongoDB enforces a <code>$stage</code> has a limit of 100 MB of consumed RAM and throws an error if exceeded. For handling large data-sets the <code>allowDiskUse=true</code> option for the overall aggregation can be defined which results in <em>sort</em> operations spilling to disk where required, to not be constrained the 100 MB limit. However, the sacrifice here is significantly higher latency, and the aggregation execution time is likely to increase by orders or magnitude. There is one situation where this can be mitigated, if the <code>$sort</code> is not preceded by a <code>$project</code>, <code>$unwind</code> or <code>$group</code> stage it can take advantage of an index for sorting, meaning it doesn't have to manifest the whole data set in memory (or overspill to disk).</p>
</li>
<li>
<p><strong>$group memory consumption</strong>: The <code>$group</code> stage has the potential to consume even more memory than a <code>$sort</code> operation, if it attempting to group all records in the source data-set and retain all the data for each grouped record. This means that the output of the <code>$group</code> stage would contain a larger size of data than the original input, because new groupings 'metadata' would be required too, and, for a period of time this would have all had to be held in memory by the <code>$group</code> blocking stage. Taking the example before of <em>people</em> records, the <code>$group</code> stage's output size would be the size of all the people records in the data-set, plus the size of the new <em>departments</em> grouping metadata. Like <code>$sort</code> stage there is a 100 MB RAM limit for the <code>$group</code> stage, and the aggregation's <code>allowDiskUse=true</code> option can enable the group operation to overspill to disk to avoid this limit, but with the similar higher latency consequences. However, in practicality, many types of grouping operations are primarily used to generate grouped summary data, not grouped itemised data. Therefore, in many situation where <code>$group</code> stages are used, considerably reduced summary data-sets are produced, requiring far less memory than a <code>$sort</code> stage.  For example, rather then the each <em>department</em> group holding a list of its <em>employees</em>, each group might just hold a <em>count</em> of employees in the department by using an <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulators-group">accumulator operators</a>. So, in reality, unlike sort operations, in many cases grouping operations will only require a fraction of the RAM, due only summary statistics being needed for each group.</p>
</li>
</ol>
<p>In summary, try to move <code>$sort</code> &amp; <code>$group</code> blocking stages to as late in the pipeline as possible. Then, hopefully due to earlier stages that first significantly reduce the number of records being streamed, these blocking stages have less records to process and hence have less thirst for RAM, resulting in an aggregation that completes quickly.</p>
<h2 id="avoid-unwinding--regrouping-documents-just-to-process-each-arrays-elements"><a class="header" href="#avoid-unwinding--regrouping-documents-just-to-process-each-arrays-elements">Avoid Unwinding &amp; Regrouping Documents Just To Process Each Array's Elements</a></h2>
<p>Sometimes it is necessary to transform documents from a source collection that each include an array field, where the main purpose of the aggregation pipeline is just to reduce the content of each array, in isolation, but in the same way. For example, the aggregation may just need to add together all the values of the array into a total, or retain the first or last element of the array only, or retain only one field from the sub-document that is in each array element, or any one of numerous other array <em>reduction</em> scenarios.</p>
<p>Bringing this to life more, imagine there is a <code>product_orders</code> collection where each document in the collection represents a product, and the list of orders is an array of elements against each product, as shown in the example below:</p>
<pre><code class="language-javascript">[
  {
    name: 'Asus Laptop',
    orders: [
      {
        customer_id: 'elise_smith@myemail.com',
        orderdate: 2020-05-30T08:35:52.000Z,
        value: Decimal128(&quot;431.43&quot;)
      },
      {
        customer_id: 'jjones@tepidmail.com',
        orderdate: 2020-12-26T08:55:46.000Z,
        value: Decimal128(&quot;429.65&quot;)
      }
    ]
  },
  {
    name: 'Morphy Richards Food Mixer',
    orders: [
      {
        customer_id: 'oranieri@warmmail.com',
        orderdate: 2020-01-01T08:25:37.000Z,
        value: Decimal128(&quot;63.13&quot;)
      }
    ]
  }
]
</code></pre>
<p>Let's say that an aggregation is required to transform these documents to only include the <code>customer_id</code> in each order for each product, and to exclude the <code>orderdate</code> and <code>value</code> fields because they are surplus to requirements. The desired aggregation output might be:</p>
<pre><code class="language-javascript">[
  {
    name: 'Asus Laptop',
    orders: [ 'elise_smith@myemail.com', 'jjones@tepidmail.com' ]
  },
  {
    name: 'Morphy Richards Food Mixer',
    orders: [ 'oranieri@warmmail.com' ]
  }
]
</code></pre>
<p>One obvious way of achieving this transformation in an aggregation pipeline is to <em>unwind</em> the <em>orders</em> array for each record, producing an intermediate set of individual order records, and then <em>group</em> together again the orders records by product <code>$name</code> but only pushing the <code>customer_id</code> field back into the <code>orders</code> array and ignoring the <code>orderdate</code> and <code>value</code> fields. The required pipeline to achieve this is shown below:</p>
<pre><code class="language-javascript">// SUBOPTIMAL

var pipeline = [
  {'$unwind': {
    'path': '$orders',
  }},

  {'$group': {
    '_id': '$name',
    'orders': {'$push': '$orders.customer_id'},
  }},
];

</code></pre>
<p>However, the pipeline is suboptimal because a <code>$group</code> stage has been introduced, which, as outlined earlier in this chapter, is a blocking stage. This will potentially increase memory consumption  significantly and hence the execution time dramatically, if run against a large data-set. There is a far better alternative, which is to use one of the <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/#array-expression-operators">Array Operators</a> instead. Array Operators are sometimes less intuitive to code, but critically, they avoid requiring the need to introduce a blocking stage into the pipeline. As a consequence they are significantly more optimal, especially for large data-sets. Shown below is a far more efficient pipeline, using the <code>$map</code> array operator, rather then the <code>$unwind/$group</code> combination, to produce the same outcome:</p>
<pre><code class="language-javascript">// OPTIMAL

var pipeline = [
  {'$set': {
    'orders': {
      '$map': {
        'input': '$orders',
        'as': 'order',
        'in': '$$order.customer_id',
      }
    },    
  }},
];
</code></pre>
<p>There should never be the need to use an <code>$unwind/$group</code> combination in an aggregation pipeline just to transform an array of elements contained in each document. Instead, use <em>Array Operators</em> to avoid introducing a blocking stage, which, when a pipeline is handling more than 100MB of in-flight data will result in magnitudes of reduction in execution time. It may even mean the difference between being able to achieve the required business outcome, using an aggregation, versus having to abandon the whole task as being unachievable.</p>
<p>In summary, the primary use of an <code>$unwind/$group</code> combination is to correlate patterns across many records, rather than transform the content inside each input record in isolation. An example of an appropriate use of <code>$unwind/$group</code> is shown in this book's <a href="../simple-examples/unpack-array-group-differently.html">Unpack Array &amp; Group Differently</a> example.</p>
<h2 id="encourage-match-filters-to-appear-early-in-a-pipeline"><a class="header" href="#encourage-match-filters-to-appear-early-in-a-pipeline">Encourage Match Filters To Appear Early In A Pipeline</a></h2>
<p>As discussed in this book's <a href="./explain.html">Using Explain Plans</a> chapter, the database engine will do its best to optimise the aggregation pipeline at runtime, with a particular focus on moving the <code>$match</code> stage contents to the top of the pipeline, if possible, to form part of the filters that are first executed as a query by the aggregation. This helps to maximise the opportunity for an index to be optimally leveraged at the start of the aggregation. However, it may not always be possible to promote <code>$match</code> filters in such a way without changing the meaning and resulting output of an aggregation.</p>
<p>Sometimes there are situations where <code>$match</code> stage is defined later in a pipeline and is performing a filter on a field which was only manifested part way into the pipeline and therefore wasn't present in the source collection that the aggregation operated on. For example, perhaps a <code>$group</code> stages creates a new <code>total</code> field based on an accumulator and the <code>$match</code> stage then looks for records where the <code>total</code> is greater than <code>1000</code>. Or perhaps a <code>$set</code>stage computes a new  <code>total</code> field value based on adding up all the elements of an array field in the same document, and the <code>$match</code> then looks for records where the <code>total</code> is less than <code>50</code>.</p>
<p>At first glance, it may seem like nothing can be further done to optimise the pipeline by promoting the position of a specific <code>$match</code> stage, and sometimes that will be the reality. In other situations though, there may be a missed opportunity where a refactoring is indeed possible to enable such an optimisation.</p>
<p>Take the following trivial example of a collection of <em>customer orders</em> documents:</p>
<pre><code class="language-javascript">[
  {
    customer_id: 'elise_smith@myemail.com',
    orderdate: 2020-05-30T08:35:52.000Z,
    value: Decimal128(&quot;9999&quot;)
  },
  {
    customer_id: 'elise_smith@myemail.com',
    orderdate: 2020-01-13T09:32:07.000Z,
    value: Decimal128(&quot;10101&quot;)
  }
]
</code></pre>
<p>Let's assume the orders are based on a <em>Dollars</em> currency, and each <code>value</code> field shows the order's value in <em>cents</em>. A pipeline may have been built to show all orders where the value is greater than 100 dollars:</p>
<pre><code class="language-javascript">// SUBOPTIMAL

var pipeline = [
  {'$set': {
    'value_dollars': {'$multiply': [0.01, '$value']},
  }},
  
  {'$unset': [
    '_id',
    'value',
  ]},         

  {'$match': {
    'value_dollars': {'$gte': 100},  // Peforms a dollar check
  }},    
];
</code></pre>
<p>Although the collection has an index defined for the <code>value</code> field (which is in <em>cents</em>), the <code>$match</code> filter for this pipeline is based on a computed field, <code>value_dollars</code> and hence, if you run the explain plan for the this aggregation, you will see that the <code>$match</code> filter has not been pushed to the top of the pipeline and an index has not been leveraged. The <code>$match</code> stage filtering on <code>value_dollars</code> can at best only by pushed upwards at runtime by the aggregation engine to just after the <code>$set</code> stage, and not to the start of the pipeline. MongoDB's aggregation engine is clever enough to track dependencies for a particular field referenced in multiple stages in a pipeline. Hence it is able to establish how far up the pipeline it can promote fields without risking a change in the external behaviour and outcome of the aggregation. In this case it knows that the <code>$match</code> stage cannot be pushed ahead of the <code>set</code> stage which it depends on.</p>
<p>By now it is probably obvious that in this example, as a developer, you can easily make a pipeline modification that will enable this pipeline to be optimised without changing the intended outcome of the pipeline. For this pipeline, simply by changing the <code>$match</code> filter to be based on the source field <code>value</code> being greater than <code>10000</code> cents, rather than being based on the computed field <code>value_dollars</code> greater then <code>100</code> dollars, and ensuring the <code>$match</code> stage appears before the <code>$unset</code> stage (which removes the <code>value</code> field) it is enough to allow the pipeline run efficiently. Below is the pipeline after being optimised by the developer:</p>
<pre><code class="language-javascript">// OPTIMAL

var pipeline = [
  {'$set': {
    'value_dollars': {'$multiply': [0.01, '$value']},
  }},
  
  {'$match': {                // Moved to before the $unset
    'value': {'$gte': 10000},   // Changed to not perform a cents check
  }},    

  {'$unset': [
    '_id',
    'value',
  ]},         
];
</code></pre>
<p>This pipeline produces the exact same results but if you were to look at its explain plan you now would see that the <code>$match</code> filter has been pushed to the top of the pipeline, when executed, and the index on <code>value</code> is now being leveraged. For completeness, in this case, the developer might as well move the modified <code>$match</code> stage to be the first stage in the pipeline explicitly, but this wasn't mandatory, as can be seen by the explain plan. The aggregation runtime has now been able to perform that optimisation itself because the <code>$match</code> stage is no longer 'blocked' by a dependency on computed field dependency.</p>
<p>There may be some cases, where it isn't possible to unravel a computed value in such a way entirely. However, it may still be possible to include an additional <code>$match</code> stage, to perform a <em>partial match</em>, earlier in the pipeline. For example, lets say a computed field masks a sensitive <code>date_of_birth</code> field into a new <code>masked date</code> field by adding a random few days to the date, up to a maximum of 7 days. An existing <code>$match</code> stage's filter in the pipeline might already have been defined to only include records where <code>masked date</code> is greater than <code>01-Jan-2020</code>. At this point, as a manual refactoring optimisation, an additional (not replacement) <code>$match</code> can be added, right at the start of the pipeline, with the filter <code>date_of_birth &gt; 25-Dec-2020</code> (7 days before the previously existing <code>$match</code> filter). This doesn't mean that the output of the overall aggregation has changed with potentially more records being output. This is because the original <code>$match</code> stage still exists in the pipeline to catch any <em>stragglers</em>, but now, early in pipeline, there is <em>partially effective</em> filter, which is leveraging an index, and which won't necessarily filter out all undesired records, but it will quickly filter out the vast majority of them, leaving any records from the remaining 7 days window of time to be filtered out as normal later in the pipeline.</p>
<p>In summary, if you have a pipeline leveraging <code>$match</code> stages and the explain plan shows the pipeline is not being optimised to promote the <code>$match</code> filter to be at the start of the pipeline (and leveraging an index), explore whether the match filter is based on a computed field, from say a <code>$group</code> or <code>$set</code> stage, and whether instead, it can be fully or partly <em>unravelled</em> and based on a source field's value. </p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../guides/explain.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../guides/expressions.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../guides/explain.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../guides/expressions.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
