<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Practical MongoDB Aggregations Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn how to develop effective and optimal data manipulation and analytics pipelines with this book, using the MongoDB Aggregation Framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    
        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-D0T2GQ8R19"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-D0T2GQ8R19');
        </script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="front-cover.html">Practical MongoDB Aggregations</a></li><li class="chapter-item expanded affix "><a href="credits.html">Credits</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Foreword</a></li><li class="chapter-item expanded affix "><a href="who-this-is-for.html">Who This Book Is For</a></li><li class="chapter-item expanded "><a href="intro/introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="intro/introducing-aggregations.html"><strong aria-hidden="true">1.1.</strong> Introducing MongoDB Aggregations</a></li><li class="chapter-item expanded "><a href="intro/history.html"><strong aria-hidden="true">1.2.</strong> History of MongoDB Aggregations</a></li></ol></li><li class="chapter-item expanded "><a href="guides/guides.html"><strong aria-hidden="true">2.</strong> Guiding Tips &amp; Principles</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="guides/getting-started.html"><strong aria-hidden="true">2.1.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="guides/getting-help.html"><strong aria-hidden="true">2.2.</strong> Getting Help</a></li><li class="chapter-item expanded "><a href="guides/composibility.html"><strong aria-hidden="true">2.3.</strong> Embrace Composability For Increased Productivity</a></li><li class="chapter-item expanded "><a href="guides/project.html"><strong aria-hidden="true">2.4.</strong> Better Alternatives To A Project Stage</a></li><li class="chapter-item expanded "><a href="guides/explain.html"><strong aria-hidden="true">2.5.</strong> Using Explain Plans</a></li><li class="chapter-item expanded "><a href="guides/performance.html"><strong aria-hidden="true">2.6.</strong> Pipeline Performance Considerations</a></li><li class="chapter-item expanded "><a href="guides/expressions.html"><strong aria-hidden="true">2.7.</strong> Expressions Explained</a></li></ol></li><li class="chapter-item expanded "><a href="examples/examples.html"><strong aria-hidden="true">3.</strong> Aggregations By Example</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/simple-examples/simple-examples.html"><strong aria-hidden="true">3.1.</strong> Simple Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/simple-examples/filtered-top-subset.html"><strong aria-hidden="true">3.1.1.</strong> Filtered Top Subset</a></li><li class="chapter-item expanded "><a href="examples/simple-examples/group-and-total.html"><strong aria-hidden="true">3.1.2.</strong> Group &amp; Total</a></li><li class="chapter-item expanded "><a href="examples/simple-examples/unpack-array-group-differently.html"><strong aria-hidden="true">3.1.3.</strong> Unpack Arrays &amp; Group Differently</a></li><li class="chapter-item expanded "><a href="examples/simple-examples/convert-to-strongly-typed.html"><strong aria-hidden="true">3.1.4.</strong> Strongly Typed Conversion</a></li><li class="chapter-item expanded "><a href="examples/simple-examples/one-to-one-join.html"><strong aria-hidden="true">3.1.5.</strong> One-to-One Join</a></li></ol></li><li class="chapter-item expanded "><a href="examples/moderate-examples/moderate-examples.html"><strong aria-hidden="true">3.2.</strong> Moderate Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/moderate-examples/multi-one-to-many.html"><strong aria-hidden="true">3.2.1.</strong> Multi-Field Join &amp; One-to-Many</a></li><li class="chapter-item expanded "><a href="examples/moderate-examples/faceted-classifications.html"><strong aria-hidden="true">3.2.2.</strong> Faceted Classification</a></li><li class="chapter-item expanded "><a href="examples/moderate-examples/restricted-view.html"><strong aria-hidden="true">3.2.3.</strong> Restricted View</a></li><li class="chapter-item expanded "><a href="examples/moderate-examples/largest-graph-network.html"><strong aria-hidden="true">3.2.4.</strong> Largest Graph Network</a></li></ol></li><li class="chapter-item expanded "><a href="examples/intricate-examples/intricate-examples.html"><strong aria-hidden="true">3.3.</strong> Intricate Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/intricate-examples/incremental-analytics.html"><strong aria-hidden="true">3.3.1.</strong> Incremental Analytics</a></li><li class="chapter-item expanded "><a href="examples/intricate-examples/mask-sensitive-fields.html"><strong aria-hidden="true">3.3.2.</strong> Mask Sensitive Fields</a></li><li class="chapter-item expanded "><a href="examples/intricate-examples/convert-incomplete-dates.html"><strong aria-hidden="true">3.3.3.</strong> Convert Incomplete Date Strings</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="back-cover.html"></a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Practical MongoDB Aggregations Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./pics/cover.png" alt="Practical MongoDB Aggregations book front cover" /></p>
<p> </p>
<h1 id="practical-mongodb-aggregations"><a class="header" href="#practical-mongodb-aggregations">Practical MongoDB Aggregations</a></h1>
<p>Author: Paul Done (<a href="https://twitter.com/TheDonester">@TheDonester</a>)</p>
<p>Version: 1.03</p>
<p>Book published at: <a href="https://www.practical-mongodb-aggregations.com">www.practical-mongodb-aggregations.com</a></p>
<p>Content created &amp; assembled at: <a href="https://github.com/pkdone/practical-mongodb-aggregations-book">github.com/pkdone/practical-mongodb-aggregations-book</a></p>
<hr />
<p>Acknowledgements - many thanks to the following people for their valuable feedback:</p>
<ul>
<li>Jake McInteer</li>
<li>John Page</li>
<li>Asya Kamsky</li>
<li>Mat Keep</li>
</ul>
<hr />
<p>Front cover image adapted from a <a href="https://www.pexels.com/photo/red-steel-pipe-2420294/">Photo by Henry &amp; Co. from Pexels</a> under the <a href="https://www.pexels.com/license/">Pexels License</a> <em>(free to use &amp; modify)</em></p>
<hr />
<p><a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="https://img.shields.io/badge/License-CC%20BY--NC--SA%203.0-lightgrey.svg" alt="CC BY-NC-SA 3.0" /></a></p>
<p>This work is licensed under a <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons Attribution-NonCommercial-ShareAlike 3.0 License</a></p>
<p><a href="https://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="https://licensebuttons.net/l/by-nc-sa/3.0/88x31.png" alt="CC BY-NC-SA 3.0" /></a></p>
<p>Copyright © 2021 MongoDB, Inc.</p>
<h1 id="foreword"><a class="header" href="#foreword">Foreword</a></h1>
<p><strong>By Asya Kamsky</strong> (<a href="https://twitter.com/asya999">@asya999</a>)</p>
<p>I've been involved with databases since the early 1990's when I &quot;accidentally&quot; got a job with a small database company.  For the next two decades, databases were synonymous with SQL in my mind, until someone asked me what I thought about these new &quot;No SQL&quot; databases, and MongoDB in particular.  I tried MongoDB for a small project I was doing on the side, and the rest, as they say, is history. </p>
<p>When I joined the company that created MongoDB in early 2012, the query language was simple and straightforward but didn't include options for easy data aggregation, because the general advice was &quot;store the data the way you expect to access the data&quot;, which was a fantastic approach for fast point queries. As time went on, though, it became clear that sometimes you want to answer questions that you didn't know you'd have when you were first designing the application, and the options for that within the database itself were limited. Map-Reduce was complicated to understand and get right, and required writing and running JavaScript, which was inefficient. This led to a new way to aggregate data natively in the server, which was called &quot;The Aggregation Framework&quot;. Since the stages of data processes were organized as a pipeline (familiarly evoking processing files on the Unix command line, for those of us who did such things a lot) we also referred to it as &quot;The Aggregation Pipeline&quot;. Very quickly &quot;Agg&quot; became my favorite feature for its flexibility, power and ease of debugging.</p>
<p>We've come a long away in the last nine years, starting with just seven stages and three dozen expressions operating on a single collection, to where we are now: over thirty stages, including special stages providing input to the pipeline, allowing powerful output from the pipeline, including data from other collections in a pipeline, and over one hundred and fifty expressions, available not just in the aggregation command but also in queries and updates. </p>
<p>The nature of data is such that we will never know up-front all the questions we will have about it in the future, so being able to construct complex queries (aka aggregations) about it is critical to success.  While complex data processing can be performed in any programming language you are comfortable with, being able to analyze your data without having to move it from where it's currently stored provides a tremendous advantage over exporting and loading the data elsewhere just to be able to use it for your analytics. </p>
<p>For years, I've given talks about the power of the Aggregation Pipeline, answered questions from users about how to do complex analysis with it, and frequently fielded requests for a comprehensive &quot;Aggregation Cookbook&quot;. Of course it would be great to have a repository of &quot;recipes&quot; with which to solve common data tasks that involve more than a single stage or expression combination, but it's hard to find the time to sit down and write something like that. This is why I was so stoked to see that my colleague, Paul Done, had just written this book and laid the foundation for that cookbook.</p>
<p>I hope you find this collection of suggestions, general principles, and specific pipeline examples useful in your own application development and I look forward to seeing it grow over time to become the cookbook that will help everyone realize the full power of their data.</p>
<h1 id="who-this-book-is-for"><a class="header" href="#who-this-book-is-for">Who This Book Is For</a></h1>
<p>This book is for developers, architects, data analysts, data engineers and data scientists who have some familiarity with MongoDB and have already acquired a small amount of rudimentary experience using the MongoDB Aggregation Framework. If you do not yet have this entry level knowledge, don't worry because there are plenty of getting started guides out there. If you've never used the Aggregation Framework before, you should start with one or more of the following resources before using this book:</p>
<ul>
<li>The <a href="https://docs.mongodb.com/manual/">MongoDB Manual</a>, and specifically its <a href="https://docs.mongodb.com/manual/aggregation/">Aggregation</a> section</li>
<li>The <a href="https://university.mongodb.com/">MongoDB University</a> free online courses, and specifically <a href="https://university.mongodb.com/courses/M121/about">The MongoDB Aggregation Framework (M121)</a> introduction course</li>
<li>The <a href="https://www.oreilly.com/library/view/mongodb-the-definitive/9781491954454/">MongoDB: The Definitive Guide</a> book by Bradshaw, Brazil &amp; Chodorow, and specifically its section <em>7. Introduction to the Aggregation Framework</em></li>
</ul>
<p>This book is not for complete novices, explaining how you should get started on your first MongoDB aggregation pipeline. Neither is this book a comprehensive programming language guide detailing every nuance of the Aggregation Framework and its syntax. This book intends to assist you with two key aspects:</p>
<ol>
<li>Providing a set of opinionated yet easy to digest principles and approaches for increasing your effectiveness in using the Aggregation Framework</li>
<li>Providing a set of examples for using the Aggregation Framework to solve common data manipulation challenges with varying degrees of complexity</li>
</ol>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This introduction section of the book helps you understand what MongoDB Aggregations are, the philosophy of Aggregations, what people use them for, and the history of the framework.</p>
<h1 id="introducing-mongodb-aggregations"><a class="header" href="#introducing-mongodb-aggregations">Introducing MongoDB Aggregations</a></h1>
<h2 id="what-are-mongodb-aggregations"><a class="header" href="#what-are-mongodb-aggregations">What Are MongoDB Aggregations?</a></h2>
<p>MongoDB's aggregation pipeline language is somewhat of a paradox. It can appear daunting, yet it is straightforward. It can seem verbose, yet it is lean and to the point. It is <a href="https://en.wikipedia.org/wiki/Turing_completeness">Turing complete</a> and able to solve any business problem <strong>*</strong>. Conversely, it is a strongly opinionated <a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain Specific Language (DSL)</a>, where, if you attempt to veer away from its core purpose of mass data manipulation, it will try its best to resist you.</p>
<blockquote>
<p><strong>*</strong> <em>As <a href="http://ilearnasigoalong.blogspot.com/">John Page</a> once showed, you can even code a <a href="https://github.com/johnlpage/MongoAggMiner">Bitcoin miner</a> using MongoDB aggregations, not that he (or hopefully anyone for that matter) would ever recommend you do this for real, for both the sake of your bank balance and the environment!</em></p>
</blockquote>
<p>Invariably, for beginners, the Aggregation Framework seems difficult to understand and comes with an initially steep learning curve that you must overcome to become productive. In some programming languages, you only need to master a small set of the language's aspects to be largely effective. With MongoDB aggregations, the initial effort you must invest is slightly greater. However, once mastered, users find it provides an elegant, natural and efficient solution to breaking down a complex set of data manipulations into a series of simple easy to understand steps. This is the point when users achieve the Zen of MongoDB Aggregations, and it is a lovely place to be.</p>
<p>MongoDB's aggregation pipeline language is focused on data-oriented problem-solving rather than business process problem-solving. It is essentially a <a href="https://en.wikipedia.org/wiki/Declarative_programming">declarative programming language</a>, rather than an <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperative programming language</a>. Also, depending on how you squint, it can be regarded as a <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming language</a> rather than a <a href="https://en.wikipedia.org/wiki/Procedural_programming">procedural programming language</a>. Why? Well, an aggregation pipeline is an ordered series of declarative statements, called stages, where the entire output of one stage forms the entire input of the next stage, and so on, with no side effects. This functional nature is probably why many users regard the Aggregation Framework as having a steeper learning curve than many languages. Not because it is inherently more difficult to understand but because most developers come from a procedural programming background and not a functional one. Most developers also have to learn how to think like a functional programmer to learn the Aggregation Framework.</p>
<p>The Aggregation Framework's declarative and functional characteristics ultimately make it especially powerful for processing massive data sets. Users focus more on defining 'the what' in terms of the required outcome in a declarative way. Users focus less on 'the how' of specifying the exact logic to apply to achieve each transformation. You provide one specific and clear advertised purpose for each stage in the pipeline. At runtime, the database engine can then understand the exact intent of each stage. For example, the database engine can obtain clear answers to the questions it asks, such as, &quot;is this stage for performing a filter or is this stage for grouping on some fields?&quot;. With this knowledge, the database engine has the opportunity to optimise the pipeline at runtime. The diagram below shows an example of the database performing a pipeline optimisation. It may decide to re-order stages to optimally leverage an index whilst ensuring that the output isn't changed. Or, it may choose to execute some steps in parallel against subsets of the data in different shards, reducing response time whilst again ensuring the output is never changed.</p>
<p><img src="intro/./pics/optimise.png" alt="MongoDB Aggregation Framework developer vs database engine optimizations comparison" /></p>
<p>Last and by far least in terms of importance is a discussion about syntax. So far, MongoDB aggregations have been described here as a programming language, which it is (a Domain Specific Language). However, with what syntax is a MongoDB aggregation pipeline constructed? The answer is &quot;it depends&quot;, and the answer is mostly irrelevant. This book will highlight pipeline examples using MongoDB's Shell and the JavaScript interpreter it runs in. The book will express aggregation pipelines using a <a href="https://en.wikipedia.org/wiki/JSON">JSON</a> based syntax. However, if you are using one of the many <a href="https://docs.mongodb.com/drivers/">programming language drivers</a> that MongoDB provides, you will be using that language to construct an aggregation pipeline, not JSON. An aggregation is specified as an array of objects, regardless of how the programming language may facilitate this. This programmatic rather than textual format has a couple of advantages compared to querying with a string. It has a low vulnerability to <a href="https://en.wikipedia.org/wiki/SQL_injection">injection attacks</a>, and it is highly <a href="https://en.wikipedia.org/wiki/Composability">composable</a>.</p>
<h2 id="whats-in-a-name"><a class="header" href="#whats-in-a-name">What's In A Name?</a></h2>
<p>You might have realised by now that there doesn't seem to be one single name for the subject of this book. You will often hear:</p>
<ul>
<li>Aggregation</li>
<li>Aggregations</li>
<li>Aggregation Framework</li>
<li>Aggregation Pipeline</li>
<li>Aggregation Pipelines</li>
<li>Aggregation Language</li>
<li>Agg</li>
<li><em>...and so on</em></li>
</ul>
<p>The reality is that any of these names are acceptable, and it doesn't matter which you use. This book uses most of these terms at some point. Just take it as a positive sign that this MongoDB capability (and its title) was not born in a marketing boardroom. It was built by database engineers, for data engineers, where the branding was an afterthought at best!</p>
<h2 id="what-do-people-use-the-aggregation-framework-for"><a class="header" href="#what-do-people-use-the-aggregation-framework-for">What Do People Use The Aggregation Framework For?</a></h2>
<p>The Aggregation Framework is versatile and used for many different data processing and manipulation tasks. Some typical example uses are for:</p>
<ul>
<li>Real-time analytics</li>
<li>Report generation with roll-ups, sums &amp; averages</li>
<li>Real-time dashboards</li>
<li>Redacting data to present via views</li>
<li>Joining data together from different collections on the 'server-side'</li>
<li>Data science, including data discovery and data wrangling</li>
<li>Mass data analysis at scale (a la '<a href="https://en.wikipedia.org/wiki/Big_data">big data</a>')</li>
<li>Real-time queries where deeper 'server-side' data post-processing is required than provided by the MongoDB Query Language (<a href="https://docs.mongodb.com/manual/crud/">MQL</a>)</li>
<li>Copying and transforming subsets of data from one collection to another</li>
<li>Navigating relationships between records, looking for patterns</li>
<li>Data masking to obfuscate sensitive data</li>
<li>Performing the Transform (T) part of an Extract-Load-Transform (<a href="https://en.wikipedia.org/wiki/Extract,_load,_transform">ELT</a>) workload</li>
<li>Data quality reporting and cleansing</li>
<li>Updating a materialised view with the results of the most recent source data changes</li>
<li>Representing data ready to be exposed via SQL/ODBC/JDBC (using MongoDB's <a href="https://docs.mongodb.com/bi-connector/">BI Connector</a>)</li>
<li>Supporting machine learning frameworks for efficient data analysis (e.g. via MongoDB's <a href="https://docs.mongodb.com/spark-connector">Spark Connector</a>)</li>
<li><em>...and many more</em></li>
</ul>
<h1 id="history-of-mongodb-aggregations"><a class="header" href="#history-of-mongodb-aggregations">History Of MongoDB Aggregations</a></h1>
<h2 id="the-emergence-of-aggregations"><a class="header" href="#the-emergence-of-aggregations">The Emergence Of Aggregations</a></h2>
<p>MongoDB's developers released the first major version of the database (version 1.0) in February 2009. Back then, both users and the predominant company behind the database, <a href="https://en.wikipedia.org/wiki/MongoDB_Inc.">MongoDB Inc.</a> (called <em>10gen</em> at the time) were still establishing the sort of use cases that the database would excel at and where the critical gaps were. Within half a year of this first major release, MongoDB's engineering team had identified a need to enable materialised views to be generated on-demand. Users needed this capability to maintain counts, sums, and averages for their real-time client applications to query. In December 2009, in time for the following major release (1.2), the database engineers introduced a quick tactical solution to address this gap. This solution involved embedding a JavaScript engine in the database and allowing client applications to submit and execute 'server-side' logic using a simple <a href="https://docs.mongodb.com/manual/core/map-reduce/">Map-Reduce</a> API.</p>
<p>A <a href="https://en.wikipedia.org/wiki/MapReduce">Map-Reduce</a> workload essentially does two things. Firstly it scans the entire data set, looking for the matching subset of records required for the given scenario. This phase may also transform or exclude the fields of each record. This is the 'map' action. Secondly, it condenses the subset of matched data into grouped, totalled, and averaged result summaries. This is the 'reduce' action. Functionally, MongoDB's <em>Map-Reduce</em> capability provides a solution to users' typical data processing requirements, but it comes with the following drawbacks:</p>
<ol>
<li>The database has to bolt in an inherently slow JavaScript engine to execute users' Map-Reduce code.</li>
<li>Users have to provide two sets of JavaScript logic, a <em>map</em> (or matching) function and a <em>reduce</em> (or grouping) function. Neither is very intuitive to develop, lacking a solid data-oriented bias.</li>
<li>At runtime, the lack of ability to explicitly associate a specific intent to an arbitrary piece of logic means that the database engine has no opportunity to identify and apply optimisations. It is hard for it to target indexes or re-order some logic for more efficient processing. The database has to be conservative, executing the workload with minimal concurrency and employing locks at various times to prevent race conditions and inconsistent results.</li>
<li>Poor scalability because the monolithic and opaque nature of Map-Reduce logic means the database engine can't break parts of it up and execute these parts in parallel across multiple shards.</li>
</ol>
<p>Over the following two years, as user behaviour with Map-Reduce became more understood, MongoDB engineers started to envision a better solution. Also, users were increasingly trying to use Map-Reduce to perform mass data processing given MongoDB's ability to hold large data sets. They were hitting the same Map-Reduce limitations. Users desired a more targeted capability leveraging a data-oriented Domain Specific Language (DSL). The engineers saw how to deliver a framework enabling a developer to define a series of data manipulation steps with valuable composability characteristics. Each step would have a clear advertised intent, allowing the database engine to apply optimisations at runtime. The engineers could also design a framework that would execute 'natively' in the database and not require a JavaScript engine. In August 2012, this solution, called the Aggregation Framework, was introduced in the 2.2 version of MongoDB. MongoDB's Aggregation Framework provided a far more powerful, efficient, scalable and easy to use replacement to Map-Reduce.</p>
<p>Within its first year, the Aggregation Framework rapidly became the go-to tool for processing large volumes of data in MongoDB. Now, nearly a decade on, it is like the Aggregation Framework has always been part of MongoDB. It feels like part of the database's core DNA. MongoDB still supports Map-Reduce, but developers rarely use it nowadays. MongoDB's aggregations are always the correct answer for processing data in the database!</p>
<blockquote>
<p><em>It is not widely known, but MongoDB's engineering team re-implemented the Map-Reduce 'back-end' in MongoDB 4.4 to execute within the aggregations runtime. They had to develop some additional aggregation stages and operators to fill some gaps. For the most part, these are internal-only stages or operators that the Aggregation Framework does not surface for developers to use in regular aggregations. The two exceptions are the new <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/function/">$function</a> and <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/accumulator/">$accumulator</a> 4.4 operators, which the refactoring work influenced and which now serve as two useful operators for use in any aggregation pipeline. In MongoDB 4.4, each Map-Reduce 'aggregation' still uses JavaScript for certain phases, and so it will not achieve the performance of a native aggregation for an equivalent workload. Nor does this change magically address the other drawbacks of Map-Reduce workloads concerning composability, concurrency,  scalability and opportunities for runtime optimisation. The primary purpose of the change was for the database engineers to eliminate redundancy and promote resiliency in the database's codebase.</em></p>
</blockquote>
<h2 id="key-releases--capabilities"><a class="header" href="#key-releases--capabilities">Key Releases &amp; Capabilities</a></h2>
<p>Below is a summary of the evolution of the Aggregation Framework in terms of significant capabilities added in each major release:</p>
<ul>
<li><strong>MongoDB 2.2 (August 2012)</strong>: Initial Release</li>
<li><strong>MongoDB 2.4 (March 2013)</strong>: Efficiency improvements (especially for sorts), a concat operator</li>
<li><strong>MongoDB 2.6 (April 2014)</strong>: Unlimited size result sets, explain plans, spill to disk for large sorts, an option to output to a new collection, a redact stage</li>
<li><strong>MongoDB 3.0 (March 2015)</strong>: Date-to-string operators</li>
<li><strong>MongoDB 3.2 (December 2015)</strong>: Sharded cluster optimisations, lookup (join) &amp; sample stages, many new arithmetic &amp; array operators</li>
<li><strong>MongoDB 3.4 (November 2016)</strong>: Graph-lookup, bucketing &amp; facets stages, many new array &amp; string operators </li>
<li><strong>MongoDB 3.6 (November 2017)</strong>: Array to/from object operators, more extensive date to/from string operators, a REMOVE variable</li>
<li><strong>MongoDB 4.0 (July 2018)</strong>: Number to/from string operators, string trimming operators</li>
<li><strong>MongoDB 4.2 (August 2019)</strong>: A merge stage to insert/update/replace records in existing non-sharded &amp; sharded collections, set &amp; unset stages to address the verbosity/rigidity of project stages, trigonometry operators, regular expression operators</li>
<li><strong>MongoDB 4.4 (July 2020)</strong>: A union stage, custom JavaScript expression operators (function &amp; accumulator), first &amp; last array element operators, string replacement operators, a random number operator</li>
</ul>
<h1 id="guiding-tips--principles"><a class="header" href="#guiding-tips--principles">Guiding Tips &amp; Principles</a></h1>
<p>This is the first of the book's two major parts, providing a small set of opinionated yet easy to digest principles and approaches for increasing effectiveness, productivity, and performance when developing aggregation pipelines.</p>
<h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>For developing aggregation pipelines effectively, and also to try the examples in the second half of this book, you need the following two elements:</p>
<ol>
<li>A <strong>MongoDB database</strong>, <strong>version 4.2 or greater</strong>, running somewhere which is network accessible from your workstation</li>
<li>A <strong>MongoDB client tool</strong> running on your workstation with which to submit aggregation execution requests and to view the results</li>
</ol>
<p>Note that each example aggregation pipeline shown in the second major part of this book is marked with the minimum version of MongoDB that you must use to execute the provided pipeline. Some example pipelines use aggregation features that MongoDB introduced in versions greater than 4.2. Where this is the case, the exact version number required is called out. For MongoDB versions 4.0 and earlier, some examples may work unchanged. Some examples may work with minor alterations, and some may not work at all due to fundamental dependencies on features added in MongoDB versions after 4.0.</p>
<h2 id="database"><a class="header" href="#database">Database</a></h2>
<p>The database deployment for you to connect to can be a single server, a replica set or a sharded cluster. You can run this deployment locally on your workstation or remotely on-prem or in the cloud. It doesn't matter which. You need to know the MongoDB URL for connecting to the database and, if authentication is enabled, the credentials required for full read and write access.</p>
<p>If you don't already have access to a MongoDB database, the two most accessible options for running a database for free are:</p>
<ol>
<li><a href="https://www.mongodb.com/cloud/atlas">Provision a Free Tier MongoDB Cluster</a> in MongoDB Atlas, which is MongoDB Inc.'s cloud-based Database-as-a-Service (once deployed, in the Atlas Console, there is a button you can click to copy the URL of the cluster)</li>
<li><a href="https://docs.mongodb.com/guides/server/install/">Install and run a MongoDB single server</a> locally on your workstation</li>
</ol>
<h2 id="client-tool"><a class="header" href="#client-tool">Client Tool</a></h2>
<p>There are many options for the client tool, four of which are:</p>
<ol>
<li><strong><em>Modern</em> Shell</strong>. Install the modern version of MongoDB's command-line tool, the <a href="https://www.mongodb.com/try/download/shell">MongoDB Shell</a>: <code>mongosh</code></li>
<li><strong><em>Legacy</em> Shell</strong>. Install the legacy version of MongoDB's command-line tool, the <a href="https://docs.mongodb.com/manual/mongo/">Mongo Shell</a>: <code>mongo</code> (you will often find this binary bundled with a MongoDB database installation or you can download it from the Atlas console)</li>
<li><strong>Compass</strong>. Install the <em>official</em> MongoDB Inc. provided graphical user interface (GUI) tool, <a href="https://www.mongodb.com/products/compass">MongoDB Compass</a></li>
<li><strong>Studio 3T</strong>. Install the <em>3rd party</em> 3T Software Labs provided graphical user interface (GUI) tool, <a href="https://studio3t.com/download/">Studio 3T</a></li>
</ol>
<p>The book's examples present code in such a way to make it easy to copy and paste into the MongoDB's Shell (<code>mongosh</code> or <code>mongo</code>) to execute. All subsequent instructions in this book assume you are using the Shell. However, you will find it straightforward to use one of the mentioned GUI tools instead to consume the code examples. Of the two Shell versions, is it is easier to use and view results with the <em>modern</em> Shell.</p>
<h3 id="mongodb-shell-with-atlas-database"><a class="header" href="#mongodb-shell-with-atlas-database">MongoDB Shell With Atlas Database</a></h3>
<p>Here is an example of how you can start the <em>modern</em> Shell to connect to an Atlas Free Tier MongoDB Cluster (change the text <code>mongosh</code> to <code>mongo</code> if you are using the <em>legacy</em> Shell):</p>
<pre><code class="language-bash">mongosh &quot;mongodb+srv://mycluster.a123b.mongodb.net/test&quot; --username myuser
</code></pre>
<p>Note before running the command above, ensure</p>
<ol>
<li>You have <a href="https://docs.atlas.mongodb.com/security/add-ip-address-to-list/">added your workstation's IP address</a> to the Atlas Access List</li>
<li>You have <a href="https://docs.atlas.mongodb.com/tutorial/create-mongodb-user-for-cluster/">created a database user</a> for the deployed Atlas cluster, with rights to create, read and write to any database</li>
<li>You have changed the dummy URL and username text, shown in the above example command, to match your real cluster's details (these details are accessible via the cluster's <code>Connect</code> button in the Atlas Console)</li>
</ol>
<h3 id="mongodb-shell-with-local-database"><a class="header" href="#mongodb-shell-with-local-database">MongoDB Shell With Local Database</a></h3>
<p>Here is an example of how you can start the <em>modern</em> Shell to connect to a MongoDB single server database if you've installed one locally on your workstation (change the text <code>mongosh</code> to <code>mongo</code> if you are using the <em>legacy</em> Shell):</p>
<pre><code class="language-bash">mongosh &quot;mongodb://localhost:27017&quot;
</code></pre>
<h3 id="mongodb-compass-gui"><a class="header" href="#mongodb-compass-gui">MongoDB Compass GUI</a></h3>
<p>MongoDB Compass provides an <em>Aggregation Pipeline Builder</em> tool to assist users in prototyping and debugging aggregation pipelines and exporting them to different programming languages. Below is a screenshot of the aggregation tool in Compass:</p>
<p><img src="guides/./pics/compass.png" alt="MongoDB Compass GUI tool for building database aggregation pipelines" /></p>
<h3 id="studio-3t-gui"><a class="header" href="#studio-3t-gui">Studio 3T GUI</a></h3>
<p>Studio 3T provides an <em>Aggregation Editor</em> tool to help users prototype and debug aggregation pipelines and translate them to different programming languages. Below is a screenshot of the aggregation tool in Studio 3T:</p>
<p><img src="guides/./pics/studio3t.png" alt="Studio 3T GUI tool for building database aggregation pipelines" /></p>
<h1 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h1>
<p>No one can hold the names and syntax of all the different aggregation stages and operators in their heads. I'd bet even <em>MongoDB Aggregations Royalty</em> (<a href="http://www.kamsky.org/stupid-tricks-with-mongodb">Asya Kamsky</a>) couldn't, although I'm sure she would give it a good go!</p>
<p>The good news is there is no need for you to try to remember all the stages &amp; operators. The MongoDB online documentation provides you with a set of excellent <em>references</em> here:</p>
<ul>
<li>MongoDB Aggregation Pipeline <a href="https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline/">Stages reference</a></li>
<li>MongoDB Aggregation Pipeline <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/">Operators reference</a></li>
</ul>
<p>Additionally, if you are getting stuck with an aggregation pipeline and want some help, an active online community will almost always have the answer. So pose your questions at either:</p>
<ul>
<li>The MongoDB Developer Hub - <a href="https://developer.mongodb.com/community/forums/">Community Forums</a></li>
<li>Stack Overflow - <a href="https://stackoverflow.com/questions/tagged/mongodb">MongoDB Questions</a></li>
</ul>
<p>You may be asking for just general advice. However, suppose you want to ask for help on a specific aggregation pipeline under development. In that case, you should provide a sample input document, a copy of your current pipeline code (in its JSON syntax format and not a programming language specific format) and an example of the output that you are trying to achieve. If you provide this extra information, you will have a far greater chance of receiving a timely and optimal response.</p>
<h1 id="embrace-composability-for-increased-productivity"><a class="header" href="#embrace-composability-for-increased-productivity">Embrace Composability For Increased Productivity</a></h1>
<p>An aggregation pipeline is an ordered series of declarative statements, called stages. The entire output of one stage forms the whole input of the next stage, and so on, with no side effects. Pipelines exhibit high <a href="https://en.wikipedia.org/wiki/Composability">composability</a> where stages are stateless self-contained components selected and assembled in various combinations (pipelines) to satisfy specific requirements. This composability promotes iterative prototyping, with straightforward testing after each increment.</p>
<p>With MongoDB's aggregations, you can take a complex problem, requiring a complex aggregation pipeline, and break it down into straightforward individual stages, where each step can be developed and tested in isolation first. To better comprehend this composability, it may be helpful to internalise the following visual model.</p>
<p><img src="guides/./pics/pipeline-equivalence.png" alt="Alternatives for MongoDB aggregation pipelines composability" /></p>
<p>Suppose you have two pipelines with one stage in each and run the second pipeline after completing the first pipeline. The final result set is the same as if you have just run a single pipeline containing both stages serially. There is no difference between the two. As a developer, you can reduce the <a href="https://en.wikipedia.org/wiki/Cognitive_load">cognitive load</a> by understanding how a problem can be broken down in this way when building aggregation pipelines. Aggregation pipelines enable you to decompose a big challenge into lots of minor challenges. By embracing this approach of first developing each stage separately, you will find even the most complex challenges become surmountable.</p>
<h2 id="specific-tips-to-promote-composability"><a class="header" href="#specific-tips-to-promote-composability">Specific Tips To Promote Composability</a></h2>
<p>In reality, once most developers become adept at using the Aggregation Framework, they tend not to rely on temporary intermediate collections whilst prototyping each stage. However, it is still a reasonable development approach if you prefer it. Instead, seasoned aggregation pipeline developers typically comment out one or more stages of an aggregation pipeline when using MongoDB's Shell (or they use the 'disable stage' capability provided by the <a href="guides/./getting-started.html">GUI tools</a> for MongoDB).</p>
<p>To encourage composability and hence productivity, some of the principles to strive for are:</p>
<ul>
<li>Easy disabling of subsets of stages, whilst prototyping or debugging</li>
<li>Easy addition of new fields to a stage or new stages to a pipeline by performing a copy, a paste and then a modification without hitting cryptic error messages resulting from issues like missing a comma before the added element</li>
<li>Easy appreciation of each distinct stage's purpose, at a glance</li>
</ul>
<p>With these principles in mind, the following is an opinionated list of guidelines for how you should textually craft your pipelines in JavaScript to improve your pipeline development pace:</p>
<ol>
<li>Don't start or end a stage on the same line as another stage</li>
<li>For every field in a stage, and stage in a pipeline, include a trailing comma even if it is currently the last item</li>
<li>Include an empty newline between every stage</li>
<li>For complex stages include a <code>//</code> comment with an explanation on a newline before the stage</li>
<li>To 'disable' some stages of a pipeline whilst prototyping or debugging another stage, use the multi-line comment <code>/*</code> prefix and <code>*/</code> suffix</li>
</ol>
<p>Below is an example of a poor pipeline layout if you have followed none of the guiding principles:</p>
<pre><code class="language-javascript">// BAD

var pipeline = [
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;address&quot;
  ]}, {&quot;$match&quot;: {
    &quot;dateofbirth&quot;: {&quot;$gte&quot;: ISODate(&quot;1970-01-01T00:00:00Z&quot;)}
  }}//, {&quot;$sort&quot;: {
  //  &quot;dateofbirth&quot;: -1
  //}}, {&quot;$limit&quot;: 2}
];
</code></pre>
<p>Whereas the following is an example of a far better pipeline layout, where you meet all of the guiding principles:</p>
<pre><code class="language-javascript">// GOOD

var pipeline = [
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;address&quot;,
  ]},    
    
  // Only match people born on or after 1st January 1970
  {&quot;$match&quot;: {
    &quot;dateofbirth&quot;: {&quot;$gte&quot;: ISODate(&quot;1970-01-01T00:00:00Z&quot;)},
  }},
  
  /*
  {&quot;$sort&quot;: {
    &quot;dateofbirth&quot;: -1,
  }},      
    
  {&quot;$limit&quot;: 2},  
  */
];
</code></pre>
<p>Notice trailing commas are included in the code snippet, at both the end of stage level and end of field level.</p>
<blockquote>
<p><em>There is an important behaviour to be aware of in MongoDB's Shell after you paste and execute a pipeline's definition with <code>var pipeline = [...];</code>. The command will appear in the Shell's history, and you can press the <code>up</code> arrow key to view the command and then press <code>enter</code> to rerun it. However, in the Shell, the historic command is stored and displayed as a single line with no newline breaks. This makes it challenging to navigate and refactor part of the code, inline in the Shell, before rerunning it. Instead, it is very common for users to refactor their 'master version' of a pipeline in an external code editor before pasting it into the Shell again to rerun. Used this way, there is no problem. Nevertheless, suppose you prefer to perform inline edits of historical commands directly in the Shell. The <code>//</code> comments in your pipeline will cause an error when the command is rerun due to the historical version being a single line. The Shell will inadvertently comment out the remaining part of the pipeline's code from where the first <code>//</code> occurs. Therefore, if you are a user who favours changing a previous pipeline definition in the Shell directly, you will need to avoid the use of <code>//</code> comments. Instead, use <code>/* ... */</code> for both single-line comments and temporarily commenting out blocks of your pipeline when debugging. However, be aware that it will be more painful for you when you need to comment out a block of the pipeline that already contains a single comment line.</em></p>
</blockquote>
<p>It is worth mentioning that some (but not all) developers take an alternative but an equally valid approach to constructing a pipeline. They decompose each stage in the pipeline into different JavaScript variables, where each stage's variable is defined separately, as shown in the example below:</p>
<pre><code class="language-javascript">// GOOD

var unsetStage = {
  &quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;address&quot;,
  ]};    

var matchStage = {
  &quot;$match&quot;: {
    &quot;dateofbirth&quot;: {&quot;$gte&quot;: ISODate(&quot;1970-01-01T00:00:00Z&quot;)},
  }};

var sortStage = {
   &quot;$sort&quot;: {
    &quot;dateofbirth&quot;: -1,
  }}; 


var limitStage = {&quot;$limit&quot;: 2};
    
var pipeline = [
  unsetStage,
  matchStage,
  sortStage,
  limitStage,
];
</code></pre>
<p>Furthermore, some developers may take additional steps if they do not intend to transfer the prototyped pipeline to a different programming language:</p>
<ul>
<li>They may choose to decompose elements inside a stage into additional JavaScript variables to avoid code 'typos'. For instance, to prevent one part of a pipeline incorrectly referencing a field computed earlier in the pipeline due to a misspelling.</li>
<li>They may choose to factor out complex boilerplate parts of a pipeline into separate JavaScript functions. They can then re-use each function from multiple places within the main pipeline's code.</li>
</ul>
<p>In summary, this book is not advocating a multi-variable approach over a single-variable approach when you define a pipeline. The book is just highlighting two highly composable options. Ultimately it is a personal choice concerning which you find most comfortable and productive. </p>
<h1 id="better-alternatives-to-a-project-stage"><a class="header" href="#better-alternatives-to-a-project-stage">Better Alternatives To A Project Stage</a></h1>
<p>The quintessential tool used in MongoDB's Query Language (MQL) to define or restrict fields to return is a <em>projection</em>. In the MongoDB Aggregation Framework, the analogous facility for specifying fields to include or exclude is the <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/project/">$project</a> stage. For many earlier versions of MongoDB, this was the only tool to define which fields to keep or omit. However, <code>$project</code> comes with a few usability challenges: </p>
<ol>
<li>
<p><strong><em>$project</em> is confusing and non-intuitive</strong>. You can only choose to include fields or exclude fields in a single stage, but not both. There is one exception, though, where you can exclude the _id field yet still define other fields to include (this only applies to the _id field). It's as if <code>$project</code> has an identity crisis.</p>
</li>
<li>
<p><strong><em>$project</em> is verbose and inflexible</strong>. If you want to define one new field or revise one field, you will have to name all other fields in the projection to include. If each input record has 100 fields and the pipeline needs to employ a <code>$project</code> stage for the first time, things become tiresome. To include a new 101st field, you now also have to name all the original 100 fields in this new <code>$project</code> stage too. You will find this irritating if you have an evolving data model, where additional new fields appear in some records over time. Because you use a <code>$project</code> for inclusion, then each time a new field appears in the data set, you must go back to the old aggregation pipeline to modify it to name the new field explicitly for inclusion in the results. This is the antithesis of flexibility and agility.</p>
</li>
</ol>
<p>In MongoDB version 4.2, the <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/set/">$set</a> and <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/unset/">$unset</a> stages were introduced, which, in most cases, are preferable to using <code>$project</code> for declaring field inclusion and exclusion. They make the code's intent much clearer, lead to less verbose pipelines, and, critically, they reduce the need to refactor a pipeline whenever the data model evolves. How this works and guidance on when to use <code>$set</code> &amp; <code>$unset</code> stages is described in the section '<em>When To Use $set &amp; $unset</em>', further below.</p>
<p>Despite the challenges, though, there are some specific situations where using <code>$project</code> is advantageous over <code>$set</code>/<code>$unset</code>. These situations are described in the section '<em>When To Use $project</em>' further below. </p>
<blockquote>
<p><em>MongoDB version 3.4 addressed some of the disadvantages of <code>$project</code> by introducing a new <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/addFields/">$addFields</a> stage, which has the same behaviour as <code>$set</code>. <code>$set</code> came later than <code>$addFields</code>and <code>$set</code> is actually just an alias for <code>$addFields</code>. However, back then, the Aggregation Framework provided no direct equivalent to <code>$unset</code>. Both <code>$set</code> and <code>$unset</code> stages are available in modern versions of MongoDB, and their counter purposes are obvious to deduce by their names (<code>$set</code> Vs <code>$unset</code>). The name <code>$addFields</code> doesn't fully reflect that you can modify existing fields rather than just adding new fields. This book prefers <code>$set</code> over <code>$addFields</code> to help promote consistency and avoid any confusion of intent. However, if you are wedded to <code>$addFields</code>, use that instead, as there is no behavioural difference.</em></p>
</blockquote>
<h2 id="when-to-use-set--unset"><a class="header" href="#when-to-use-set--unset">When To Use Set &amp; Unset</a></h2>
<p>You should use <code>$set</code> &amp; <code>$unset</code> stages when you need to retain most of the fields in the input records, and you want to add, modify or remove a minority subset of fields. This is the case for most uses of aggregation pipelines.</p>
<p>For example, imagine there is a collection of credit card payment documents similar to the following:</p>
<pre><code class="language-javascript">// INPUT  (a record from the source collection to be operated on by an aggregation)
{
  _id: ObjectId(&quot;6044faa70b2c21f8705d8954&quot;),
  card_name: &quot;Mrs. Jane A. Doe&quot;,
  card_num: &quot;1234567890123456&quot;,
  card_expiry: &quot;2023-08-31T23:59:59.736Z&quot;,
  card_sec_code: &quot;123&quot;,
  card_provider_name: &quot;Credit MasterCard Gold&quot;,
  transaction_id: &quot;eb1bd77836e8713656d9bf2debba8900&quot;,
  transaction_date: ISODate(&quot;2021-01-13T09:32:07.000Z&quot;),
  transaction_curncy_code: &quot;GBP&quot;,
  transaction_amount: NumberDecimal(&quot;501.98&quot;),
  reported: true
}
</code></pre>
<p>Then imagine an aggregation pipeline is required to produce modified versions of the documents, as shown below:</p>
<pre><code class="language-javascript">// OUTPUT  (a record in the results of the executed aggregation)
{
  card_name: &quot;Mrs. Jane A. Doe&quot;,
  card_num: &quot;1234567890123456&quot;,
  card_expiry: ISODate(&quot;2023-08-31T23:59:59.736Z&quot;), // Field type converted from text
  card_sec_code: &quot;123&quot;,
  card_provider_name: &quot;Credit MasterCard Gold&quot;,
  transaction_id: &quot;eb1bd77836e8713656d9bf2debba8900&quot;,
  transaction_date: ISODate(&quot;2021-01-13T09:32:07.000Z&quot;),
  transaction_curncy_code: &quot;GBP&quot;,
  transaction_amount: NumberDecimal(&quot;501.98&quot;),
  reported: true,
  card_type: &quot;CREDIT&quot;                               // New added literal value field
}
</code></pre>
<p>Here, shown by the <code>//</code> comments, there was a requirement to modify each document's structure slightly, to convert the <code>card_expiry</code> text field into a proper date field, and add a new <code>card_type</code> field, set to the value 'CREDIT', for every record.</p>
<p>Naively you might decide to build an aggregation pipeline using a <code>$project</code> stage to achieve this transformation, which would probably look similar to the following:</p>
<pre><code class="language-javascript">// BAD
[
  {&quot;$project&quot;: {
    // Modify a field + add a new field
    &quot;card_expiry&quot;: {&quot;$dateFromString&quot;: {&quot;dateString&quot;: &quot;$card_expiry&quot;}},
    &quot;card_type&quot;: &quot;CREDIT&quot;,        

    // Must now name all the other fields for those fields to be retained
    &quot;card_name&quot;: 1,
    &quot;card_num&quot;: 1,
    &quot;card_sec_code&quot;: 1,
    &quot;card_provider_name&quot;: 1,
    &quot;transaction_id&quot;: 1,
    &quot;transaction_date&quot;: 1,
    &quot;transaction_curncy_code&quot;: 1,
    &quot;transaction_amount&quot;: 1,
    &quot;reported&quot;: 1,                
    
    // Remove _id field
    &quot;_id&quot;: 0,
  }},
]
</code></pre>
<p>As you can see, the pipeline's stage is quite lengthy, and because you use a <code>$project</code> stage to modify/add two fields, you must also explicitly name each other existing field from the source records for inclusion. Otherwise, you will lose those fields during the transformation. Imagine if each payment document has hundreds of possible fields, rather than just ten!</p>
<p>A better approach to building the aggregation pipeline, to achieve the same results, would be to use <code>$set</code> and <code>$unset</code> instead, as shown below:</p>
<pre><code class="language-javascript">// GOOD
[
  {&quot;$set&quot;: {
    // Modified + new field
    &quot;card_expiry&quot;: {&quot;$dateFromString&quot;: {&quot;dateString&quot;: &quot;$card_expiry&quot;}},
    &quot;card_type&quot;: &quot;CREDIT&quot;,        
  }},
  
  {&quot;$unset&quot;: [
    // Remove _id field
    &quot;_id&quot;,
  ]},
]
</code></pre>
<p>This time, when you need to add new documents to the collection of existing payments, which include additional new fields, e.g. <code>settlement_date</code> &amp; <code>settlement_curncy_code</code>, no changes are required. The existing aggregation pipeline allows these new fields to appear in the results automatically. However, when using <code>$project</code>, each time the possibility of a new field arises, a developer must first refactor the pipeline to incorporate an additional inclusion declaration (e.g. <code>&quot;settlement_date&quot;: 1</code>, or <code>&quot;settlement_curncy_code&quot;: 1</code>).</p>
<h2 id="when-to-use-project"><a class="header" href="#when-to-use-project">When To Use Project</a></h2>
<p>It is best to use a <code>$project</code> stage when the required shape of output documents is very different from the input documents' shape. This situation often arises when you do not need to include most of the original fields.</p>
<p>This time for the same input payments collection, let us imagine you require a new aggregation pipeline to produce result documents. You need each output document's structure to be very different from the input structure, and you need to retain far fewer original fields, similar to the following:</p>
<pre><code class="language-javascript">// OUTPUT  (a record in the results of the executed aggregation)
{
  transaction_info: { 
    date: ISODate(&quot;2021-01-13T09:32:07.000Z&quot;),
    amount: NumberDecimal(&quot;501.98&quot;)
  },
  status: &quot;REPORTED&quot;
}
</code></pre>
<p>Using <code>$set</code>/<code>$unset</code> in the pipeline to achieve this output structure would be verbose and would require naming all the fields (for exclusion this time), as shown below:</p>
<pre><code class="language-javascript">// BAD
[
  {&quot;$set&quot;: {
    // Add some fields
    &quot;transaction_info.date&quot;: &quot;$transaction_date&quot;,
    &quot;transaction_info.amount&quot;: &quot;$transaction_amount&quot;,
    &quot;status&quot;: {&quot;$cond&quot;: {&quot;if&quot;: &quot;$reported&quot;, &quot;then&quot;: &quot;REPORTED&quot;, &quot;else&quot;: &quot;UNREPORTED&quot;}},
  }},
  
  {&quot;$unset&quot;: [
    // Remove _id field
    &quot;_id&quot;,

    // Must name all other existing fields to be omitted
    &quot;card_name&quot;,
    &quot;card_num&quot;,
    &quot;card_expiry&quot;,
    &quot;card_sec_code&quot;,
    &quot;card_provider_name&quot;,
    &quot;transaction_id&quot;,
    &quot;transaction_date&quot;,
    &quot;transaction_curncy_code&quot;,
    &quot;transaction_amount&quot;,
    &quot;reported&quot;,         
  ]}, 
]
</code></pre>
<p>However, by using <code>$project</code> for this specific aggregation, as shown below, to achieve the same results, the pipeline will be less verbose. The pipeline will have the flexibility of not requiring modification if you ever make subsequent additions to the data model, with new previously unknown fields:</p>
<pre><code class="language-javascript">// GOOD
[
  {&quot;$project&quot;: {
    // Add some fields
    &quot;transaction_info.date&quot;: &quot;$transaction_date&quot;,
    &quot;transaction_info.amount&quot;: &quot;$transaction_amount&quot;,
    &quot;status&quot;: {&quot;$cond&quot;: {&quot;if&quot;: &quot;$reported&quot;, &quot;then&quot;: &quot;REPORTED&quot;, &quot;else&quot;: &quot;UNREPORTED&quot;}},
    
    // Remove _id field
    &quot;_id&quot;: 0,
  }},
]
</code></pre>
<blockquote>
<p><em>Another potential downside can occur when using <code>$project</code> to define field inclusion, rather than using <code>$set</code> (or <code>$addFields</code>). When using <code>$project</code> to declare all required fields for inclusion, it can be easy for you to carelessly specify more fields from the source data than intended. Later on, if the pipeline contains something like a <code>$group</code> stage, this will cover up your mistake. The final aggregation's output will not include the erroneous field in the output. You might ask, &quot;Why is this a problem?&quot;. Well, what happens if you intended for the aggregation to take advantage of a <a href="https://docs.mongodb.com/manual/core/query-optimization/#covered-query">covered index query</a> for the few fields it requires, to avoid unnecessarily accessing the raw documents. In most cases, MongoDB's aggregation engine can track fields' dependencies throughout a pipeline and, left to its own devices, can understand which fields are not required. However, you would be overriding this capability by explicitly asking for the extra field. A common error is to forget to exclude the <code>_id</code> field in the projection inclusion stage, and so it will be included by default. This mistake will silently kill the potential optimisation. If you must use a <code>$project</code> stage, try to use it as late as possible in the pipeline because it is then clear to you precisely what you are asking for as the aggregation's final output. Also, unnecessary fields like <code>_id</code> may already have been identified by the aggregation engine as no longer required, due to the occurrence of an earlier <code>$group</code> stage, for example.</em></p>
</blockquote>
<h2 id="main-takeaway"><a class="header" href="#main-takeaway">Main Takeaway</a></h2>
<p>In summary, you should always look to use <code>$set</code> (or <code>$addFields</code>) and <code>$unset</code> for field inclusion and exclusion, rather than <code>$project</code>. The main exception is if you have an obvious requirement for a very different structure for result documents, where you only need to retain a small subset of the input fields.</p>
<h1 id="using-explain-plans"><a class="header" href="#using-explain-plans">Using Explain Plans</a></h1>
<p>When using the MongoDB Query Language (MQL) to develop queries, it is important to view the <a href="https://docs.mongodb.com/manual/reference/method/db.collection.explain/">explain plan</a> for a query to determine if you've used the appropriate index and if you need to optimise other aspects of the query or the data model. An explain plan allows you to understand fully the performance implications of the query you have created.</p>
<p>The same applies to aggregation pipelines and the ability to view an <em>explain plan</em> for the executed pipeline. However, with aggregations, an explain plan tends to be even more critical because considerably more complex logic can be assembled and run in the database. There are far more opportunities for performance bottlenecks to occur, requiring optimisation.</p>
<p>The MongoDB database engine will do its best to apply its own <a href="https://docs.mongodb.com/manual/core/aggregation-pipeline-optimization/">aggregation pipeline optimisations</a> at runtime. Nevertheless, there could be some optimisations that only you can make. A database engine should never optimise a pipeline in such a way as to risk changing the functional behaviour and outcome of the pipeline. The database engine doesn't always have the extra context that your brain has, relating to the actual business problem at hand. It may not be able to make some types of judgment calls about what pipeline changes to apply to make it run faster. The availability of an explain plan for aggregations enables you to bridge this gap. It allows you to understand the database engine's applied optimisations and detect further potential optimisations you can manually implement in the pipeline.</p>
<h2 id="viewing-an-explain-plan"><a class="header" href="#viewing-an-explain-plan">Viewing An Explain Plan</a></h2>
<p>To view the explain plan for an aggregation pipeline, you can execute commands such as the following:</p>
<pre><code class="language-javascript">db.coll.explain().aggregate([{&quot;$match&quot;: {&quot;name&quot;: &quot;Jo&quot;}}]);
</code></pre>
<p>In this book, you will already have seen the convention used to firstly define a separate variable for the pipeline, followed by the call to the <code>aggregate()</code> function, passing in the pipeline argument, as shown here:</p>
<pre><code class="language-javascript">db.coll.aggregate(pipeline);
</code></pre>
<p>By adopting this approach, it's easier for you to use the same pipeline definition interchangeably with different commands. Whilst prototyping and debugging a pipeline, it is handy for you to be able to quickly switch from executing the pipeline to instead generating the explain plan for the same defined pipeline, as follows:</p>
<pre><code class="language-javascript">db.coll.explain().aggregate(pipeline);
</code></pre>
<p>As with MQL, there are three different verbosity modes that you can generate an explain plan with, as shown below:</p>
<pre><code class="language-javascript">// QueryPlanner verbosity  (default if no verbosity parameter provided)
db.coll.explain(&quot;queryPlanner&quot;).aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">// ExecutionStats verbosity
db.coll.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">// AllPlansExecution verbosity 
db.coll.explain(&quot;allPlansExecution&quot;).aggregate(pipeline);
</code></pre>
<p>In most cases, you will find that running the <code>executionStats</code> variant is the most informative mode. Rather than showing just the query planner's thought process, it also provides actual statistics on the 'winning' execution plan (e.g. the total keys examined, the total docs examined, etc.). However, this isn't the default because it actually executes the aggregation in addition to formulating the query plan. If the source collection is large or the pipeline is suboptimal, it will take a while to return the explain plan result.</p>
<p>Note, the  <a href="https://docs.mongodb.com/manual/reference/method/db.collection.aggregate/">aggregate()</a> function also provides a vestigial <code>explain</code> option to ask for an explain plan to be generated and returned. Nonetheless, this is more limited and cumbersome to use, so you should avoid it.</p>
<h2 id="understanding-the-explain-plan"><a class="header" href="#understanding-the-explain-plan">Understanding The Explain Plan</a></h2>
<p>To provide an example, let us assume a shop's data set includes information on each customer and what retail orders the customer has made over the years. The <em>customer orders</em> collection contains documents similar to the following example:</p>
<pre><code class="language-javascript">{
  &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
  &quot;orders&quot;: [
    {
      &quot;orderdate&quot;: ISODate(&quot;2020-01-13T09:32:07Z&quot;),
      &quot;product_type&quot;: &quot;GARDEN&quot;,
      &quot;value&quot;: NumberDecimal(&quot;99.99&quot;)
    },
    {
      &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;),
      &quot;product_type&quot;: &quot;ELECTRONICS&quot;,
      &quot;value&quot;: NumberDecimal(&quot;231.43&quot;)
    }
  ]
}
</code></pre>
<p>You've defined an index on the <code>customer_id</code> field. You create the following aggregation pipeline to show the three most expensive orders made by a customer whose ID is <code>tonijones@myemail.com</code>, as shown below:</p>
<pre><code class="language-javascript">var pipeline = [
  // Unpack each order from customer orders array as a new separate record
  {&quot;$unwind&quot;: {
    &quot;path&quot;: &quot;$orders&quot;,
  }},
  
  // Match on only one customer
  {&quot;$match&quot;: {
    &quot;customer_id&quot;: &quot;tonijones@myemail.com&quot;,
  }},

  // Sort customer's purchases by most expensive first
  {&quot;$sort&quot; : {
    &quot;orders.value&quot; : -1,
  }},
  
  // Show only the top 3 most expensive purchases
  {&quot;$limit&quot; : 3},

  // Use the order's value as a top level field
  {&quot;$set&quot;: {
    &quot;order_value&quot;: &quot;$orders.value&quot;,
  }},
    
  // Drop the document's id and orders sub-document from the results
  {&quot;$unset&quot; : [
    &quot;_id&quot;,
    &quot;orders&quot;,
  ]},
];
</code></pre>
<p>Upon executing this aggregation against an extensive sample data set, you receive the following result:</p>
<pre><code class="language-javascript">[
  {
    customer_id: 'tonijones@myemail.com',
    order_value: NumberDecimal(&quot;1024.89&quot;)
  },
  {
    customer_id: 'tonijones@myemail.com',
    order_value: NumberDecimal(&quot;187.99&quot;)
  },
  {
    customer_id: 'tonijones@myemail.com',
    order_value: NumberDecimal(&quot;4.59&quot;)
  }
]
</code></pre>
<p>You then request the <em>query planner</em> part of the explain plan:</p>
<pre><code class="language-javascript">db.customer_orders.explain(&quot;queryPlanner&quot;).aggregate(pipeline);
</code></pre>
<p>The query plan output for this pipeline shows the following (excluding some information for brevity):</p>
<pre><code class="language-javascript">stages: [
  {
    '$cursor': {
      queryPlanner: {
        parsedQuery: { customer_id: { '$eq': 'tonijones@myemail.com' } },
        winningPlan: {
          stage: 'FETCH',
          inputStage: {
            stage: 'IXSCAN',
            keyPattern: { customer_id: 1 },
            indexName: 'customer_id_1',
            direction: 'forward',
            indexBounds: {
              customer_id: [
                '[&quot;tonijones@myemail.com&quot;, &quot;tonijones@myemail.com&quot;]'
              ]
            }
          }
        },
      }
    }
  },
  
  { '$unwind': { path: '$orders' } },
  
  { '$sort': { sortKey: { 'orders.value': -1 }, limit: 3 } },
  
  { '$set': { order_value: '$orders.value' } },
  
  { '$project': { _id: false, orders: false } }
]
</code></pre>
<p>You can deduce some illuminating insights from this query plan:</p>
<ul>
<li>
<p>To optimise the aggregation, the database engine has reordered the pipeline positioning the filter belonging to the <code>$match</code> to the top of the pipeline. The database engine moves the content of <code>$match</code> ahead of the <code>$unwind</code> stage without changing the aggregation's functional behaviour or outcome.</p>
</li>
<li>
<p>The first stage of the database optimised version of the pipeline is an <em>internal</em> <code>$cursor</code> stage, regardless of the order you placed the pipeline stages in. The <code>$cursor</code> <em>runtime</em> stage is always the first action executed for any aggregation. Under the covers, the aggregation engine re-uses the MQL query engine to perform a 'regular' query against the collection, with a filter based on the aggregation's <code>$match</code> contents. The aggregation runtime uses the resulting query cursor to pull batches of records. This is similar to how a client application with a MongoDB driver uses a query cursor when remotely invoking an MQL query to pull batches. As with a normal MQL query, the regular database query engine will try to use an index if it makes sense. In this case an index is indeed leveraged, as is visible in the embedded  <code>$queryPlanner</code> metadata, showing the <code>&quot;stage&quot; : &quot;IXSCAN&quot;</code> element and the index used, <code>&quot;indexName&quot; : &quot;customer_id_1&quot;</code>.</p>
</li>
<li>
<p>To further optimise the aggregation, the database engine has collapsed the <code>$sort</code> and <code>$limit</code> into a single <em>special internal sort stage</em> which can perform both actions in one go. In this situation, during the sorting process, the aggregation engine only has to track the current three most expensive orders in memory. It does not have to hold the whole data set in memory when sorting, which may otherwise be resource prohibitive in many scenarios, requiring more RAM than is available.</p>
</li>
</ul>
<p>You might also want to see the <em>execution stats</em> part of the explain plan. The specific new information shown in <code>executionStats</code>, versus the default of <code>queryPlanner</code>, is identical to the <a href="https://docs.mongodb.com/manual/tutorial/analyze-query-plan/">normal MQL explain plan</a> returned for a regular <code>find()</code> operation. Consequently, for aggregations, similar principles to MQL apply for spotting things like &quot;have I used the optimal index?&quot; and &quot;does my data model lend itself to efficiently processing this query?&quot;.</p>
<p>You ask for the <em>execution stats</em> part of the explain plan:</p>
<pre><code class="language-javascript">db.customer_orders.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<p>Below is a redacted example of the output you will see, highlighting some of the most relevant metadata elements you should generally focus on.</p>
<pre><code class="language-javascript">executionStats: {
  nReturned: 1,
  totalKeysExamined: 1,
  totalDocsExamined: 1,
  executionStages: {
    stage: 'FETCH',
    nReturned: 1,
    works: 2,
    advanced: 1,
    docsExamined: 1,
    inputStage: {
      stage: 'IXSCAN',
      nReturned: 1,
      works: 2,
      advanced: 1,
      keyPattern: { customer_id: 1 },
      indexName: 'customer_id_1',
      direction: 'forward',
      indexBounds: {
        customer_id: [
          '[&quot;tonijones@myemail.com&quot;, &quot;tonijones@myemail.com&quot;]'
        ]
      },
      keysExamined: 1,
    }
  }
}
</code></pre>
<p>Here, this part of the plan also shows that the aggregation uses the existing index. Because <code>totalKeysExamined</code> and <code>totalDocsExamined</code> match, the aggregation fully leverages this index to identify the required records, which is good news. Nevertheless, the targeted index doesn't necessarily mean the aggregation's query part is fully optimised. For example, if there is the need to reduce latency further, you can do some analysis to determine if the index can completely <a href="https://docs.mongodb.com/manual/core/query-optimization/#covered-query">cover the query</a>. Suppose the <em>cursor query</em> part of the aggregation is satisfied entirely using the index and does not have to examine any raw documents. In that case, you will see <code>totalDocsExamined: 0</code> in the explain plan.</p>
<h1 id="pipeline-performance-considerations"><a class="header" href="#pipeline-performance-considerations">Pipeline Performance Considerations</a></h1>
<p>Similar to any programming language, there is a downside if you prematurely optimise an aggregation pipeline. You risk producing an over-complicated solution that doesn't address the performance challenges that will manifest. As described in the previous chapter, <a href="guides/./explain.html">Using Explain Plans</a>, the tool you should use to identify opportunities for optimisation is the <em>explain plan</em>. You will typically use the explain plan during the final stages of your pipeline's development once it is functionally correct.</p>
<p>With all that said, it can still help you to be aware of some guiding principles regarding performance whilst you are prototyping a pipeline. Critically, such guiding principles will be invaluable to you once the aggregation's explain plan is analysed and if it shows that the current pipeline is sub-optimal.</p>
<p>This chapter outlines three crucial tips to assist you when creating and tuning an aggregation pipeline. For sizable data sets, adopting these principles may mean the difference between aggregations completing in a few seconds versus minutes, hours or even longer.</p>
<h2 id="1-be-cognizant-of-streaming-vs-blocking-stages-ordering"><a class="header" href="#1-be-cognizant-of-streaming-vs-blocking-stages-ordering">1. Be Cognizant Of Streaming Vs Blocking Stages Ordering</a></h2>
<p>When executing an aggregation pipeline, the database engine pulls batches of records from the initial query cursor generated against the source collection. The database engine then attempts to stream each batch through the aggregation pipeline stages. For most types of stages, referred to as <em>streaming stages</em>, the database engine will take the processed batch from one stage and immediately stream it into the next part of the pipeline. It will do this without waiting for all the other batches to arrive at the prior stage. However, two types of stages must block and wait for all batches to arrive and accumulate together at that stage. These two stages are referred to as <em>blocking stages</em> and specifically, the two types of stages that block are:</p>
<ul>
<li><code>$sort</code></li>
<li><code>$group</code> *</li>
</ul>
<blockquote>
<p>* <em>actually when stating <code>$group</code>, this also includes other less frequently used 'grouping' stages too, specifically:</em><code>$bucket</code>, <code>$bucketAuto</code>, <code>$count</code>, <code>$sortByCount</code> &amp; <code>$facet</code>  <em>(it's a stretch to call <code>$facet</code> a group stage, but in the context of this topic, it's best to think of it that way)</em></p>
</blockquote>
<p>The diagram below highlights the nature of streaming and blocking stages. Streaming stages allow batches to be processed and then passed through without waiting. Blocking stages wait for the whole of the input data set to arrive and accumulate before processing all this data together.</p>
<p><img src="guides/./pics/streaming-blocking.png" alt="MongoDB aggregation pipeline streaming Vs blocking stages" /></p>
<p>When considering <code>$sort</code> and <code>$group</code> stages, it becomes evident why they have to block. The following examples illustrate why this is the case:</p>
<ol>
<li>
<p><strong>$sort blocking example</strong>: A pipeline must sort <em>people</em> in ascending order of <em>age</em>. If the stage only sorts each batch's content before passing the batch on to the pipeline's result, only individual batches of output records are sorted by age but not the whole result set. </p>
</li>
<li>
<p><strong>$group blocking example</strong>: A pipeline must group <em>employees</em> by one of two <em>work departments</em> (either the <em>sales</em> or <em>manufacturing</em> departments). If the stage only groups employees for a batch, before passing it on, the final result contains the work departments repeated multiple times. Each duplicate department consists of some but not all of its employees. </p>
</li>
</ol>
<p>These often unavoidable blocking stages don't just increase aggregation execution time by reducing concurrency. If used without careful forethought, the throughput and latency of a pipeline will slow dramatically due to significantly increased memory consumption. The following sub-sections explore why this occurs and tactics to mitigate this.</p>
<h3 id="sort-memory-consumption-and-mitigation"><a class="header" href="#sort-memory-consumption-and-mitigation">$sort Memory Consumption And Mitigation</a></h3>
<p>Used naïvely, a <code>$sort</code> stage will need to see all the input records at once, and so the host server must have enough capacity to hold all the input data in memory. The amount of memory required depends heavily on the initial data size and the degree to which the prior stages can reduce the size. Also, multiple instances of the aggregation pipeline may be in-flight at any one time, in addition to other database workloads. These all compete for the same finite memory. Suppose the source data set is many gigabytes or even terabytes in size, and earlier pipeline stages have not reduced this size significantly. It will be unlikely that the host machine has sufficient memory to support the pipeline's blocking <code>$sort</code> stage. Therefore, MongoDB enforces every stage is limited to 100 MB of consumed RAM. The database throws an error if it exceeds this limit.</p>
<p>To avoid the memory limit obstacle, you can set the <code>allowDiskUse:true</code> option for the overall aggregation for handling large result data sets. Consequently, the pipeline's <em>sort</em> operation spills to disk if required, and the 100 MB limit no longer constrains the pipeline. However, the sacrifice here is significantly higher latency, and the execution time is likely to increase by orders of magnitude.</p>
<p>To circumvent the aggregation needing to manifest the whole data set in memory or overspill to disk, attempt to refactor your pipeline to incorporate one of the following approaches (in order of most effective first):</p>
<ol>
<li><strong>Use Index Sort</strong>. If the <code>$sort</code> stage does not depend on a <code>$unwind</code>, <code>$group</code> or <code>$project</code> stage preceding it, move the <code>$sort</code> stage to near the start of your pipeline to target an index for the sort. The aggregation runtime does not need to perform an expensive in-memory sort operation as a result. The <code>$sort</code> stage won't necessarily be the first stage in your pipeline because there may also be a <code>$match</code> stage that takes advantage of the same index. Always inspect the explain plan to ensure you are inducing the intended behaviour.</li>
<li><strong>Use Limit With Sort</strong>. If you only need the first subset of records from the sorted set of data, add a <code>$limit</code> stage directly after the <code>$sort</code> stage, limiting the results to the fixed amount you require (e.g. 10). At runtime, the aggregation engine will collapse the <code>$sort</code> and <code>$limit</code> into a single special internal sort stage which performs both actions together. The in-flight sort process only has to track the ten records in memory, which currently satisfy the executing sort/limit rule. It does not have to hold the whole data set in memory to execute the sort successfully.</li>
<li><strong>Reduce Records To Sort</strong>. Move the <code>$sort</code> stage to as late as possible in your pipeline and ensure earlier stages significantly reduce the number of records streaming into this late blocking <code>$sort</code> stage. This blocking stage will have fewer records to process and less thirst for RAM.</li>
</ol>
<h3 id="group-memory-consumption-and-mitigation"><a class="header" href="#group-memory-consumption-and-mitigation">$group Memory Consumption And Mitigation</a></h3>
<p>Like the <code>$sort</code> stage, the <code>$group</code> stage has the potential to consume a large amount of memory. The aggregation pipeline's 100 MB RAM limit equally applies to the <code>$group</code> stage. As with sorting, you can use the pipeline's <code>allowDiskUse:true</code> option to avoid this limit for heavyweight grouping operations, but with the same downsides.</p>
<p>In reality, most grouping scenarios focus on accumulating summary data such as totals, counts, averages, highs and lows, and not itemised data. In these situations, considerably reduced result data sets are produced, requiring far less processing memory than a <code>$sort</code> stage. Contrary to many sorting scenarios, grouping operations will typically demand a fraction of the host's RAM.</p>
<p>To ensure you avoid excessive memory consumption when you are looking to use a <code>$group</code> stage, adopt the following principles:</p>
<ol>
<li><strong>Avoid Unnecessary Grouping</strong>. This chapter covers this recommendation below, in far greater detail (section &quot;<em>2. Avoid Unwinding &amp; Regrouping Documents Just To Process Array Elements</em>&quot;).</li>
<li><strong>Group Summary Data Only</strong>. If the use case permits it, use the group stage to accumulate things like totals, counts and summary roll-ups only, rather than holding all the raw data of each record belonging to a group. The Aggregation Framework provides a robust set of <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/#accumulators---group-">accumulator operators</a> to help you achieve this inside a <code>$group</code> stage.</li>
</ol>
<h2 id="2-avoid-unwinding--regrouping-documents-just-to-process-array-elements"><a class="header" href="#2-avoid-unwinding--regrouping-documents-just-to-process-array-elements">2. Avoid Unwinding &amp; Regrouping Documents Just To Process Array Elements</a></h2>
<p>Sometimes, you need an aggregation pipeline to mutate or reduce an array field's content for each record. For example:</p>
<ul>
<li>You may need to add together all the values in the array into a total field</li>
<li>You may need to retain the first and last elements of the array only</li>
<li>You may need to retain only one reoccurring field for each sub-document in the array </li>
<li>...<em>or numerous other array 'reduction' scenarios</em></li>
</ul>
<p>To bring this to life, imagine a retail <code>orders</code> collection where each document contains an array of products purchased as part of the order, as shown in the example below:</p>
<pre><code class="language-javascript">[
  {
    _id: 1197372932325,
    products: [
      {
        prod_id: 'abc12345',
        name: 'Asus Laptop',
        price: NumberDecimal('429.99')
      }
    ]
  },
  {
    _id: 4433997244387,
    products: [
      {
        prod_id: 'def45678',
        name: 'Karcher Hose Set',
        price: NumberDecimal('23.43')
      },
      {
        prod_id: 'jkl77336',
        name: 'Picky Pencil Sharpener',
        price: NumberDecimal('0.67')
      },
      {
        prod_id: 'xyz11228',
        name: 'Russell Hobbs Chrome Kettle',
        price: NumberDecimal('15.76')
      }
    ]
  }
]
</code></pre>
<p>The retailer wants to see a report of all the orders but only containing the expensive products purchased by customers (e.g. having just products priced greater than 15 dollars). Consequently, an aggregation is required to filter out the inexpensive product items of each order's array. The desired aggregation output might be:</p>
<pre><code class="language-javascript">[
  {
    _id: 1197372932325,
    products: [
      {
        prod_id: 'abc12345',
        name: 'Asus Laptop',
        price: NumberDecimal('429.99')
      }
    ]
  },
  {
    _id: 4433997244387,
    products: [
      {
        prod_id: 'def45678',
        name: 'Karcher Hose Set',
        price: NumberDecimal('23.43')
      },
      {
        prod_id: 'xyz11228',
        name: 'Russell Hobbs Chrome Kettle',
        price: NumberDecimal('15.76')
      }
    ]
  }
]
</code></pre>
<p>Notice order <code>4433997244387</code> now only shows two products and is missing the inexpensive product.</p>
<p>One naïve way of achieving this transformation is to <em>unwind</em> the <em>products</em> array of each order document to produce an intermediate set of individual product records. These records can then be <em>matched</em> to retain products priced greater than 15 dollars. Finally, the products can be <em>grouped</em> back together again by each order's <code>_id</code> field. The required pipeline to achieve this is below:</p>
<pre><code class="language-javascript">// SUBOPTIMAL

var pipeline = [
  // Unpack each product from the each order's product as a new separate record
  {&quot;$unwind&quot;: {
    &quot;path&quot;: &quot;$products&quot;,
  }},

  // Match only products valued over 15.00
  {&quot;$match&quot;: {
    &quot;products.price&quot;: {
      &quot;$gt&quot;: NumberDecimal(&quot;15.00&quot;),
    },
  }},

  // Group by product type
  {&quot;$group&quot;: {
    &quot;_id&quot;: &quot;$_id&quot;,
    &quot;products&quot;: {&quot;$push&quot;: &quot;$products&quot;},    
  }},
];
</code></pre>
<p>This pipeline is suboptimal because a <code>$group</code> stage has been introduced, which is a blocking stage, as outlined earlier in this chapter. Both memory consumption and execution time will increase significantly, which could be fatal for a large input data set. There is a far better alternative by using one of the <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/#array-expression-operators">Array Operators</a> instead. Array Operators are sometimes less intuitive to code, but they avoid introducing a blocking stage into the pipeline. Consequently, they are significantly more efficient, especially for large data sets. Shown below is a far more economical pipeline, using the <code>$filter</code> array operator, rather than the <code>$unwind/$match/$group</code> combination, to produce the same outcome:</p>
<pre><code class="language-javascript">// OPTIMAL

var pipeline = [
  // Filter out products valued 15.00 or less
  {&quot;$set&quot;: {
    &quot;products&quot;: {
      &quot;$filter&quot;: {
        &quot;input&quot;: &quot;$products&quot;,
        &quot;as&quot;: &quot;product&quot;,
        &quot;cond&quot;: {&quot;$gt&quot;: [&quot;$$product.price&quot;, NumberDecimal(&quot;15.00&quot;)]},
      }
    },    
  }},
];
</code></pre>
<p>Unlike the suboptimal pipeline, the optimal pipeline will include 'empty orders' in the results for those orders that contained only inexpensive items. If this is a problem, you can include a simple <code>$match</code> stage at the start of the optimal pipeline with the same content as the <code>$match</code> stage shown in the suboptimal example.</p>
<p>To reiterate, there should never be the need to use an <code>$unwind/$group</code> combination in an aggregation pipeline to transform an array field's elements for each document in isolation. One way to recognize if you have this anti-pattern is if your pipeline contains a <code>$group</code> on a <code>$_id</code> field. Instead, use <em>Array Operators</em> to avoid introducing a blocking stage. Otherwise, you will suffer a magnitude of increase in execution time when your pipeline handles more than 100MB of in-flight data. Adopting this best practice may mean the difference between achieving the required business outcome and abandoning the whole task as unachievable.</p>
<p>The primary use of an <code>$unwind/$group</code> combination is to correlate patterns across many records' arrays rather than transforming the content within each input record's array only. For an illustration of an appropriate use of <code>$unwind/$group</code> refer to this book's <a href="guides/../examples/simple-examples/unpack-array-group-differently.html">Unpack Array &amp; Group Differently</a> example.</p>
<h2 id="3-encourage-match-filters-to-appear-early-in-the-pipeline"><a class="header" href="#3-encourage-match-filters-to-appear-early-in-the-pipeline">3. Encourage Match Filters To Appear Early In The Pipeline</a></h2>
<p>As discussed, the database engine will do its best to optimise the aggregation pipeline at runtime, with a particular focus on attempting to move the <code>$match</code> stages to the top of the pipeline. Top-level <code>$match</code> content will form part of the filter that the engine first executes as the initial query. The aggregation then has the best chance of leveraging an index. However, it may not always be possible to promote <code>$match</code> filters in such a way without changing the meaning and resulting output of an aggregation.</p>
<p>Sometimes, a <code>$match</code> stage is defined later in a pipeline to perform a filter on a field that the pipeline computed in an earlier stage. The computed field isn't present in the pipeline's original input collection. Some examples are:</p>
<ul>
<li>A pipeline where a <code>$group</code> stage creates a new <code>total</code> field based on an <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/group/#accumulators-group">accumulator operator</a>. Later in the pipeline, a <code>$match</code> stage filters groups where each group's <code>total</code> is greater than <code>1000</code>. </li>
<li>A pipeline where a <code>$set</code> stage computes a new <code>total</code> field value based on adding up all the elements of an array field in each document. Later in the pipeline, a <code>$match</code> stage filters documents where the <code>total</code> is less than <code>50</code>.</li>
</ul>
<p>At first glance, it may seem like the match on the computed field is irreversibly trapped behind an earlier stage that computed the field's value. Indeed the aggregation engine cannot automatically optimise this further. In some situations, though, there may be a missed opportunity where beneficial refactoring is possible by you, the developer.</p>
<p>Take the following trivial example of a collection of <em>customer order</em> documents:</p>
<pre><code class="language-javascript">[
  {
    customer_id: 'elise_smith@myemail.com',
    orderdate: ISODate('2020-05-30T08:35:52.000Z'),
    value: NumberDecimal('9999')
  }
  {
    customer_id: 'elise_smith@myemail.com',
    orderdate: ISODate('2020-01-13T09:32:07.000Z'),
    value: NumberDecimal('10101')
  }
]
</code></pre>
<p>Let's assume the orders are in a <em>Dollars</em> currency, and each <code>value</code> field shows the order's value in <em>cents</em>. You may have built a pipeline to display all orders where the value is greater than 100 dollars like below:</p>
<pre><code class="language-javascript">// SUBOPTIMAL

var pipeline = [
  {&quot;$set&quot;: {
    &quot;value_dollars&quot;: {&quot;$multiply&quot;: [0.01, &quot;$value&quot;]}, // Converts cents to dollars
  }},
  
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;value&quot;,
  ]},         

  {&quot;$match&quot;: {
    &quot;value_dollars&quot;: {&quot;$gte&quot;: 100},  // Peforms a dollar check
  }},    
];
</code></pre>
<p>The collection has an index defined for the <code>value</code> field (in <em>cents</em>). However, the <code>$match</code> filter uses a computed field, <code>value_dollars</code>. When you view the explain plan, you will see the pipeline does not leverage the index. The <code>$match</code> is trapped behind the <code>$set</code> stage (which computes the field) and cannot be moved to the pipeline's start. MongoDB's aggregation engine tracks a field's dependencies across multiple stages in a pipeline. It can establish how far up the pipeline it can promote fields without risking a change in the aggregation's behaviour. In this case, it knows that if it moves the <code>$match</code> stage ahead of the <code>$set</code> stage, it depends on, things will not work correctly.</p>
<p>In this example, as a developer, you can easily make a pipeline modification that will enable this pipeline to be more optimal without changing the pipeline's intended outcome. Change the <code>$match</code> filter to be based on the source field <code>value</code> instead (greater than <code>10000</code> cents), rather than the computed field (greater than <code>100</code> dollars). Also, ensure the <code>$match</code> stage appears before the <code>$unset</code> stage (which removes the <code>value</code> field). This change is enough to allow the pipeline to run efficiently. Below is how the pipeline looks after you have made  this change:</p>
<pre><code class="language-javascript">// OPTIMAL

var pipeline = [
  {&quot;$set&quot;: {
    &quot;value_dollars&quot;: {&quot;$multiply&quot;: [0.01, &quot;$value&quot;]},
  }},
  
  {&quot;$match&quot;: {                // Moved to before the $unset
    &quot;value&quot;: {&quot;$gte&quot;: 10000},   // Changed to perform a cents check
  }},    

  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;value&quot;,
  ]},         
];
</code></pre>
<p>This pipeline produces the same data output. However, when you look at its explain plan, it shows the database engine has pushed the <code>$match</code> filter to the top of the pipeline and used an index on the <code>value</code> field. The aggregation is now optimal because the <code>$match</code> stage is no longer 'blocked' by its dependency on the computed field.</p>
<p>There may be some cases where you can't unravel a computed value in such a manner. However, it may still be possible for you to include an additional <code>$match</code> stage, to perform a <strong>partial match</strong> targeting the aggregation's query cursor. Suppose you have a pipeline that masks the values of sensitive <code>date_of_birth</code> fields (replaced with computed <code>masked_date</code> fields). The computed field adds a random number of days (one to seven) to each current date. The pipeline already contains a <code>$match</code> stage with the filter <code>masked_date &gt; 01-Jan-2020</code>. The runtime cannot optimise this to the top of the pipeline due to the dependency on a computed value. Nevertheless, you can manually add an extra <code>$match</code> stage at the top of the pipeline, with the filter <code>date_of_birth &gt; 25-Dec-2019</code>. This new <code>$match</code> leverages an index and filters records seven days earlier than the existing <code>$match</code>, but the aggregation's final output is the same. The new <code>$match</code> may pass on a few more records than intended. However, later on, the pipeline applies the existing filter <code>masked_date &gt; 01-Jan-2020</code> that will naturally remove surviving surplus records before the pipeline completes.</p>
<p>In summary, if you have a pipeline leveraging a <code>$match</code> stage and the explain plan shows this is not moving to the start of the pipeline, explore whether manually refactoring will help. If the <code>$match</code> filter depends on a computed value, examine if you can alter this or add an extra <code>$match</code> to yield a more efficient pipeline.</p>
<h1 id="expressions-explained"><a class="header" href="#expressions-explained">Expressions Explained</a></h1>
<h2 id="what-are-aggregation-expressions"><a class="header" href="#what-are-aggregation-expressions">What Are Aggregation Expressions?</a></h2>
<p>Expressions give aggregation pipelines their data manipulation power. However, they tend to be something that developers start using by just copying examples from the MongoDB Manual and then refactoring these without thinking enough about what they are. Proficiency in aggregation pipelines demands a deeper understanding of expressions.</p>
<p>Expressions come in one of three primary flavours:</p>
<ul>
<li>
<p><strong>Operators.</strong> Accessed with a <code>$</code> prefix followed by the operator function name. These are used as the keys for objects.  Examples:  <code>$arrayElemAt</code>, <code>$cond</code>, <code>$dateToString</code></p>
</li>
<li>
<p><strong>Field Paths.</strong> Accessed with a <code>$</code> prefix followed by the field's path in each record being processed.  Examples: <code>$account.sortcode</code>, <code>$addresses.address.city</code></p>
</li>
<li>
<p><strong>Variables.</strong> Accessed with a <code>$$</code> prefix followed by the fixed name and falling into three sub-categories:</p>
<ul>
<li>
<p><strong>Context system variables.</strong> With values coming from the system environment rather than each input record an aggregation stage is processing.  Examples:  <code>$$NOW</code>, <code>$$CLUSTER_TIME</code></p>
</li>
<li>
<p><strong>Marker flag system variables.</strong> To indicate desired behaviour to pass back to the aggregation runtime.  Examples: <code>$$ROOT</code>, <code>$$REMOVE</code>, <code>$$PRUNE</code></p>
</li>
<li>
<p><strong>Bind user variables.</strong> For storing values you declare with a <code>$let</code> operator (or with the 'let' option of a <code>$lookup</code> stage, or 'as' option of a <code>$map</code> or <code>$filter</code> stage).  Examples: <code>$$product_name_var</code>, <code>$$order_id_var</code></p>
</li>
</ul>
</li>
</ul>
<p>You can combine these three categories of expressions when operating on input records, enabling you to perform complex comparisons and transformations of data. To highlight this, the code snippet below is an excerpt from this book's <a href="guides/../examples/intricate-examples/mask-sensitive-fields.html">Mask Sensitive Fields</a> example, which combines all three expressions.</p>
<pre><code class="language-javascript">&quot;customer_info&quot;: {&quot;$cond&quot;: {
                    &quot;if&quot;:   {&quot;$eq&quot;: [&quot;$customer_info.category&quot;, &quot;SENSITIVE&quot;]}, 
                    &quot;then&quot;: &quot;$$REMOVE&quot;,     
                    &quot;else&quot;: &quot;$customer_info&quot;,
                 }}
</code></pre>
<p>The pipeline retains an embedded sub-document (<code>customer_info</code>) in each resulting record unless a field in the original sub-document has a specific value (<code>category=SENSITIVE</code>). <code>$cond</code> is one of the operator expressions used in the excerpt (a 'conditional' expression operator which takes three arguments: <code>if</code>, <code>then</code> &amp; <code>else</code>). <code>$eq</code> is another expression operator (a 'comparison' expression operator). <code>$$REMOVE</code> is a 'marker flag' variable expression instructing the pipeline to exclude the field. Both <code>$customer_info.category</code> and <code>$customer_info</code> elements are field path expressions referencing each incoming record's fields.</p>
<h2 id="where-expressions-are-used"><a class="header" href="#where-expressions-are-used">Where Expressions Are Used</a></h2>
<p>The following question is something you may not have asked yourself before, but asking this question and considering why the answer is what it is can help reveal more about what expressions are and why you use them.</p>
<p><strong>Question:</strong> Can expressions be used within any type of pipeline stage?</p>
<p><strong>Answer:</strong> No</p>
<p>There are many types of stages in the Aggregation Framework that don't allow expressions to be embedded. Examples of some of the most commonly used of these stages are:</p>
<ul>
<li><code>$match</code></li>
<li><code>$limit</code></li>
<li><code>$skip</code></li>
<li><code>$sort</code></li>
<li><code>$count</code></li>
<li><code>$lookup</code></li>
<li><code>$out</code></li>
</ul>
<p>Some of these stages may be a surprise to you if you've never really thought about it before. You might well consider <code>$match</code> to be the most surprising item in this list. The content of a <code>$match</code> stage is just a set of query conditions with the same syntax as MQL rather than an aggregation expression. There is a good reason for this. The aggregation engine re-uses the MQL query engine to perform a 'regular' query against the collection, enabling the query engine to use all its usual optimisations. The query conditions are taken as-is from the <code>$match</code> stage at the top of the pipeline. Therefore, the <code>$match</code> filter must use the same syntax as MQL. </p>
<p>In most of the stages that are unable to leverage expressions, it doesn't usually make sense for their behaviour to be dynamic, based on the pipeline data entering the stage. For a client application that paginates results, you might define a value of <code>20</code> for the<code>$limit</code> stage. However, maybe you want to dynamically bind a value to the <code>$limit</code> stage, sourced by a <code>$lookup</code> stage earlier in the pipeline. The lookup operation might pull in the user's preferred 'page list size' value from a 'user preferences' collection. Nonetheless, the Aggregation Framework does not support this today for the listed stage types to avoid the overhead of the extra checks it would need to perform for what are primarily rare cases.</p>
<p>Only one of the listed stages needs to be more expressive: the <code>$match</code> stage, but this stage is already flexible by being based on MQL query conditions. </p>
<h2 id="what-is-using-expr-inside-match-all-about"><a class="header" href="#what-is-using-expr-inside-match-all-about">What Is Using $expr Inside $match All About?</a></h2>
<p>Complicating things a little, in more recent MongoDB versions, the statement about <code>$match</code> not supporting expressions is inaccurate. MongoDB version 3.6 introduced the <a href="https://docs.mongodb.com/manual/reference/operator/query/expr/">$expr operator</a> used in regular MQL queries and hence in <code>$match</code> stages too. Inside an  <code>$expr</code> operator, you can include any composite expression fashioned from <code>$</code> operator functions, <code>$</code> field paths and <code>$$</code> variables.</p>
<p>A few situations demand having to use <code>$expr</code> from inside a <code>$match</code> stage. Examples include:</p>
<ul>
<li>A requirement to compare two fields from the same record to determine whether to keep the record based on the comparison's outcome</li>
<li>A requirement to perform a calculation based on values from multiple existing fields in each record and then comparing the calculation to a constant</li>
</ul>
<p>These are impossible in an aggregation (or MQL <code>find()</code>) if you use regular <code>$match</code> query conditions.</p>
<p>Take the example of a collection holding information on different instances of rectangles (capturing their width and height), similar to the following: </p>
<pre><code class="language-javascript">[
  { _id: 1, width: 2, height: 8 },
  { _id: 2, width: 3, height: 4 },
  { _id: 3, width: 20, height: 1 }
]
</code></pre>
<p>What if you wanted to run an aggregation pipeline to only return rectangles with an <code>area</code> greater than <code>12</code>? This comparison isn't possible in a conventional aggregation when using a single <code>$match</code> query condition. However, with <code>$expr</code>, you can analyse a combination of fields in-situ using expressions. You can implement the requirement with the following pipeline:</p>
<pre><code class="language-javascript">var pipeline = [
  {&quot;$match&quot;: {
    &quot;$expr&quot;: {&quot;$gt&quot;: [{&quot;$multiply&quot;: [&quot;$width&quot;, &quot;$height&quot;]}, 12]},
  }},      
];
</code></pre>
<p>The result of executing an aggregation with this pipeline is:</p>
<pre><code class="language-javascript">[
  { _id: 1, width: 2, height: 8 },
  { _id: 3, width: 20, height: 1 }
]
</code></pre>
<p>As you can see, the second of the three shapes is not output because its area is only <code>12</code> (<code>3 x 4</code>).</p>
<p>You should be aware that in many cases, the query engine cannot benefit from an index when using a <code>$expr</code> operator inside a <code>$match</code> stage. Specifically, if you use a 'range' comparison operator (<code>$gt</code>, <code>$gte</code>, <code>$lt</code> and <code>$lte</code>) with a field, no index will be employed to match the field. You should only use the <code>$expr</code> operator in a <code>$match</code> stage if there is no other way of assembling the criteria using regular MQL syntax criteria.</p>
<h1 id="aggregations-by-example"><a class="header" href="#aggregations-by-example">Aggregations By Example</a></h1>
<p>This is the second of the book's two major parts, providing a set of examples to solve common data manipulation challenges with varying degrees of complexity. The best way to use these examples is to try them out yourself as you read each example (see <a href="examples/../guides/getting-started.html">Getting Started</a> for advice on how to execute these examples).</p>
<h1 id="simple-examples"><a class="header" href="#simple-examples">Simple Examples</a></h1>
<p>This section provides examples for using the Aggregation Framework to solve common data manipulation challenges where the examples are relatively straightforward to understand and adapt.</p>
<h1 id="filtered-top-subset"><a class="header" href="#filtered-top-subset">Filtered Top Subset</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario"><a class="header" href="#scenario">Scenario</a></h2>
<p>You want to query a collection of people to find the three youngest people who have a job in engineering, sorted by the youngest person first.</p>
<p>This example is the only one in the book that you can also achieve entirely using MQL and serves as a helpful comparison between MQL and Aggregation Pipelines.</p>
<h2 id="sample-data-population"><a class="header" href="#sample-data-population">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>persons</code> collection with 5 person documents:</p>
<pre><code class="language-javascript">use book-filtered-top-subset;
db.dropDatabase();

// Create an index for a persons collection
db.persons.createIndex({&quot;vocation&quot;: 1, &quot;dateofbirth&quot;: 1});

// Insert records into the persons collection
db.persons.insertMany([
  {
    &quot;person_id&quot;: &quot;6392529400&quot;,
    &quot;firstname&quot;: &quot;Elise&quot;,
    &quot;lastname&quot;: &quot;Smith&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1972-01-13T09:32:07Z&quot;),
    &quot;vocation&quot;: &quot;ENGINEER&quot;,
    &quot;address&quot;: { 
        &quot;number&quot;: 5625,
        &quot;street&quot;: &quot;Tipa Circle&quot;,
        &quot;city&quot;: &quot;Wojzinmoj&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;1723338115&quot;,
    &quot;firstname&quot;: &quot;Olive&quot;,
    &quot;lastname&quot;: &quot;Ranieri&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1985-05-12T23:14:30Z&quot;),    
    &quot;gender&quot;: &quot;FEMALE&quot;,
    &quot;vocation&quot;: &quot;ENGINEER&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 9303,
        &quot;street&quot;: &quot;Mele Circle&quot;,
        &quot;city&quot;: &quot;Tobihbo&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;8732762874&quot;,
    &quot;firstname&quot;: &quot;Toni&quot;,
    &quot;lastname&quot;: &quot;Jones&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1991-11-23T16:53:56Z&quot;),    
    &quot;vocation&quot;: &quot;POLITICIAN&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 1,
        &quot;street&quot;: &quot;High Street&quot;,
        &quot;city&quot;: &quot;Upper Abbeywoodington&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;7363629563&quot;,
    &quot;firstname&quot;: &quot;Bert&quot;,
    &quot;lastname&quot;: &quot;Gooding&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1941-04-07T22:11:52Z&quot;),    
    &quot;vocation&quot;: &quot;FLORIST&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 13,
        &quot;street&quot;: &quot;Upper Bold Road&quot;,
        &quot;city&quot;: &quot;Redringtonville&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;1029648329&quot;,
    &quot;firstname&quot;: &quot;Sophie&quot;,
    &quot;lastname&quot;: &quot;Celements&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1959-07-06T17:35:45Z&quot;),    
    &quot;vocation&quot;: &quot;ENGINEER&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 5,
        &quot;street&quot;: &quot;Innings Close&quot;,
        &quot;city&quot;: &quot;Basilbridge&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;7363626383&quot;,
    &quot;firstname&quot;: &quot;Carl&quot;,
    &quot;lastname&quot;: &quot;Simmons&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1998-12-26T13:13:55Z&quot;),    
    &quot;vocation&quot;: &quot;ENGINEER&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 187,
        &quot;street&quot;: &quot;Hillside Road&quot;,
        &quot;city&quot;: &quot;Kenningford&quot;,
    },
  },
]);
</code></pre>
<h2 id="aggregation-pipeline"><a class="header" href="#aggregation-pipeline">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Match engineers only
  {&quot;$match&quot;: {
    &quot;vocation&quot;: &quot;ENGINEER&quot;,
  }},
    
  // Sort by youngest person first
  {&quot;$sort&quot;: {
    &quot;dateofbirth&quot;: -1,
  }},      
    
  // Only include the first 3 youngest people
  {&quot;$limit&quot;: 3},  

  // Exclude unrequired fields from each person record
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;vocation&quot;,
    &quot;address&quot;,
  ]},    
];
</code></pre>
<h2 id="execution"><a class="header" href="#execution">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.persons.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.persons.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results"><a class="header" href="#expected-results">Expected Results</a></h2>
<p>Three documents should be returned, representing the three youngest people who are engineers (ordered by youngest first), omitting the <code>_id</code> or <code>address</code> attributes of each person, as shown below:</p>
<pre><code class="language-javascript">[
  {
    person_id: '7363626383',
    firstname: 'Carl',
    lastname: 'Simmons',
    dateofbirth: ISODate('1998-12-26T13:13:55.000Z')
  },
  {
    person_id: '1723338115',
    firstname: 'Olive',
    lastname: 'Ranieri',
    dateofbirth: ISODate('1985-05-12T23:14:30.000Z'),
    gender: 'FEMALE'
  },
  {
    person_id: '6392529400',
    firstname: 'Elise',
    lastname: 'Smith',
    dateofbirth: ISODate('1972-01-13T09:32:07.000Z')
  }
]
</code></pre>
<h2 id="observations"><a class="header" href="#observations">Observations</a></h2>
<ul>
<li>
<p><strong>Index Use.</strong> A basic aggregation pipeline, where if many records belong to the collection, a compound index for <code>vocation + dateofbirth</code> should exist to enable the database to fully optimise the execution of the pipeline combining the filter of the <code>$match</code> stage with the sort from the <code>sort</code> stage and the limit of the <code>limit</code> stage.</p>
</li>
<li>
<p><strong>Unset Use.</strong> An <code>$unset</code> stage is used rather than a <code>$project</code> stage. This enables the pipeline to avoid being verbose. More importantly, it means the pipeline does not have to be modified if a new field appears in documents added in the future (for example, see the <code>gender</code> field that appears in only <em>Olive's</em> record).</p>
</li>
<li>
<p><strong>MQL Similarity.</strong> For reference, the MQL equivalent for you to achieve the same result is shown below (you can try this in the <em>Shell</em>):</p>
</li>
</ul>
<pre><code class="language-javascript">db.persons.find(
    {&quot;vocation&quot;: &quot;ENGINEER&quot;},
    {&quot;_id&quot;: 0, &quot;vocation&quot;: 0, &quot;address&quot;: 0},
  ).sort(
    {&quot;dateofbirth&quot;: -1}
  ).limit(3);
</code></pre>
<h1 id="group--total"><a class="header" href="#group--total">Group &amp; Total</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-1"><a class="header" href="#scenario-1">Scenario</a></h2>
<p>You want to generate a report to show what each shop customer purchased in 2020. You will group the individual order records by customer, capturing each customer's first purchase date, the number of orders they made, the total value of all their orders and a list of their order items sorted by date. </p>
<h2 id="sample-data-population-1"><a class="header" href="#sample-data-population-1">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>orders</code> collection with 9 order documents spanning 2019-2021, for 3 different unique customers:</p>
<pre><code class="language-javascript">use book-group-and-total;
db.dropDatabase();

// Create index for an orders collection
db.orders.createIndex({&quot;orderdate&quot;: -1});

// Insert records into the orders collection
db.orders.insertMany([
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;231.43&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-01-13T09:32:07Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;99.99&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;2.01&quot;),
  },  
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-11-23T22:56:53Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;187.99&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-08-18T23:04:48Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;4.59&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;48.50&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2021-02-29T07:49:32Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;1024.89&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-10-03T13:49:44Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;102.24&quot;),
  },
]);
</code></pre>
<h2 id="aggregation-pipeline-1"><a class="header" href="#aggregation-pipeline-1">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Match only orders made in 2020
  {&quot;$match&quot;: {
    &quot;orderdate&quot;: {
      &quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;),
      &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;),
    },
  }},
  
  // Sort by order date ascending (required to pick out 'first_purchase_date' below)
  {&quot;$sort&quot;: {
    &quot;orderdate&quot;: 1,
  }},      

  // Group by customer
  {&quot;$group&quot;: {
    &quot;_id&quot;: &quot;$customer_id&quot;,
    &quot;first_purchase_date&quot;: {&quot;$first&quot;: &quot;$orderdate&quot;},
    &quot;total_value&quot;: {&quot;$sum&quot;: &quot;$value&quot;},
    &quot;total_orders&quot;: {&quot;$sum&quot;: 1},
    &quot;orders&quot;: {&quot;$push&quot;: {&quot;orderdate&quot;: &quot;$orderdate&quot;, &quot;value&quot;: &quot;$value&quot;}},
  }},
  
  // Sort by each customer's first purchase date
  {&quot;$sort&quot;: {
    &quot;first_purchase_date&quot;: 1,
  }},    
  
  // Set customer's ID to be value of the field that was grouped on
  {&quot;$set&quot;: {
    &quot;customer_id&quot;: &quot;$_id&quot;,
  }},
  
  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
  ]},   
];
</code></pre>
<h2 id="execution-1"><a class="header" href="#execution-1">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.orders.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.orders.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-1"><a class="header" href="#expected-results-1">Expected Results</a></h2>
<p>Three documents should be returned, representing the three customers, each showing the customer's first purchase date, the total value of all their orders, the number of orders they made and a list of each order's detail, for 2020 only, as shown below:</p>
<pre><code class="language-javascript">[
  {
    customer_id: 'oranieri@warmmail.com',
    first_purchase_date: ISODate('2020-01-01T08:25:37.000Z'),
    total_value: NumberDecimal('63.13'),
    total_orders: 1,
    orders: [
      {orderdate: ISODate('2020-01-01T08:25:37.000Z'), value: NumberDecimal('63.13')}
    ]
  },
  {
    customer_id: 'elise_smith@myemail.com',
    first_purchase_date: ISODate('2020-01-13T09:32:07.000Z'),
    total_value: NumberDecimal('482.16'),
    total_orders: 4,
    orders: [
      {orderdate: ISODate('2020-01-13T09:32:07.000Z'), value: NumberDecimal('99.99')},
      {orderdate: ISODate('2020-05-30T08:35:52.000Z'), value: NumberDecimal('231.43')},
      {orderdate: ISODate('2020-10-03T13:49:44.000Z'), value: NumberDecimal('102.24')},
      {orderdate: ISODate('2020-12-26T08:55:46.000Z'), value: NumberDecimal('48.50')}
    ]
  },
  {
    customer_id: 'tj@wheresmyemail.com',
    first_purchase_date: ISODate('2020-08-18T23:04:48.000Z'),
    total_value: NumberDecimal('192.58'),
    total_orders: 2,
    orders: [
      {orderdate: ISODate('2020-08-18T23:04:48.000Z'), value: NumberDecimal('4.59')},
      {orderdate: ISODate('2020-11-23T22:56:53.000Z'), value: NumberDecimal('187.99')}
    ]
  }
]
</code></pre>
<p><em>Note, the order of fields shown for each document may vary.</em></p>
<h2 id="observations-1"><a class="header" href="#observations-1">Observations</a></h2>
<ul>
<li>
<p><strong>Double Sort Use.</strong> It is necessary to perform a <code>$sort</code> on the order date both before and after the <code>$group</code> stage. The <code>$sort</code> before the <code>$group</code> is required because the <code>$group</code> stage uses a <code>$first</code> group accumulator to capture just the first order's <code>orderdate</code> value for each grouped customer. The <code>$sort</code> after the <code>$group</code> is required because the act of having just grouped on customer ID will mean that the records are no longer sorted by purchase date for the records coming out of the <code>$group</code> stage.</p>
</li>
<li>
<p><strong>Renaming Group.</strong> Towards the end of the pipeline, you will see what is a typical pattern for pipelines that use <code>$group</code>, consisting of a combination of <code>$set</code>+<code>$unset</code> stages, to essentially take the group's key (which is always called <code>_id</code>) and substitute it with a more meaningful name (<code>customer_id</code>).</p>
</li>
<li>
<p><strong>Lossless Decimals.</strong> You may notice the pipeline uses a <code>NumberDecimal()</code> function to ensure the order amounts in the inserted records are using a lossless decimal type, <a href="https://docs.mongodb.com/manual/tutorial/model-monetary-data/">IEEE 754 decimal128</a>. In this example, if you use a JSON <em>float</em> or <em>double</em> type instead, the order totals will suffer from a loss of precision. For instance, for the customer <code>elise_smith@myemail.com</code>, if you use a <em>double</em> type, the <code>total_value</code> result will have the value shown in the second line below, rather than the first line:</p>
</li>
</ul>
<pre><code class="language-javascript">// Desired result achieved by using decimal128 types
total_value: NumberDecimal('482.16')

// Result that occurs if using float or double types instead
total_value: 482.15999999999997
</code></pre>
<h1 id="unpack-arrays--group-differently"><a class="header" href="#unpack-arrays--group-differently">Unpack Arrays &amp; Group Differently</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-2"><a class="header" href="#scenario-2">Scenario</a></h2>
<p>You want to generate a retail report to list the total value and quantity of expensive products sold (valued over 15 dollars). The source data is a list of shop orders, where each order contains the set of products purchased as part of the order.</p>
<h2 id="sample-data-population-2"><a class="header" href="#sample-data-population-2">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>orders</code> collection where each document contains an array of products purchased:</p>
<pre><code class="language-javascript">use book-unpack-array-group-differently;
db.dropDatabase();

// Insert 4 records into the orders collection each with 1+ product items
db.orders.insertMany([
  {
    &quot;order_id&quot;: 6363763262239,
    &quot;products&quot;: [
      {
        &quot;prod_id&quot;: &quot;abc12345&quot;,
        &quot;name&quot;: &quot;Asus Laptop&quot;,
        &quot;price&quot;: NumberDecimal(&quot;431.43&quot;),
      },
      {
        &quot;prod_id&quot;: &quot;def45678&quot;,
        &quot;name&quot;: &quot;Karcher Hose Set&quot;,
        &quot;price&quot;: NumberDecimal(&quot;22.13&quot;),
      },
    ],
  },
  {
    &quot;order_id&quot;: 1197372932325,
    &quot;products&quot;: [
      {
        &quot;prod_id&quot;: &quot;abc12345&quot;,
        &quot;name&quot;: &quot;Asus Laptop&quot;,
        &quot;price&quot;: NumberDecimal(&quot;429.99&quot;),
      },
    ],
  },
  {
    &quot;order_id&quot;: 9812343774839,
    &quot;products&quot;: [
      {
        &quot;prod_id&quot;: &quot;pqr88223&quot;,
        &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;,
        &quot;price&quot;: NumberDecimal(&quot;431.43&quot;),
      },
      {
        &quot;prod_id&quot;: &quot;def45678&quot;,
        &quot;name&quot;: &quot;Karcher Hose Set&quot;,
        &quot;price&quot;: NumberDecimal(&quot;21.78&quot;),
      },
    ],
  },
  {
    &quot;order_id&quot;: 4433997244387,
    &quot;products&quot;: [
      {
        &quot;prod_id&quot;: &quot;def45678&quot;,
        &quot;name&quot;: &quot;Karcher Hose Set&quot;,
        &quot;price&quot;: NumberDecimal(&quot;23.43&quot;),
      },
      {
        &quot;prod_id&quot;: &quot;jkl77336&quot;,
        &quot;name&quot;: &quot;Picky Pencil Sharpener&quot;,
        &quot;price&quot;: NumberDecimal(&quot;0.67&quot;),
      },
      {
        &quot;prod_id&quot;: &quot;xyz11228&quot;,
        &quot;name&quot;: &quot;Russell Hobbs Chrome Kettle&quot;,
        &quot;price&quot;: NumberDecimal(&quot;15.76&quot;),
      },
    ],
  },
]);
</code></pre>
<h2 id="aggregation-pipeline-2"><a class="header" href="#aggregation-pipeline-2">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Unpack each product from the each order's product as a new separate record
  {&quot;$unwind&quot;: {
    &quot;path&quot;: &quot;$products&quot;,
  }},

  // Match only products valued greater than 15.00
  {&quot;$match&quot;: {
    &quot;products.price&quot;: {
      &quot;$gt&quot;: NumberDecimal(&quot;15.00&quot;),
    },
  }},
  
  // Group by product type, capturing each product's total value + quantity
  {&quot;$group&quot;: {
    &quot;_id&quot;: &quot;$products.prod_id&quot;,
    &quot;product&quot;: {&quot;$first&quot;: &quot;$products.name&quot;},
    &quot;total_value&quot;: {&quot;$sum&quot;: &quot;$products.price&quot;},
    &quot;quantity&quot;: {&quot;$sum&quot;: 1},
  }},

  // Set product id to be the value of the field that was grouped on
  {&quot;$set&quot;: {
    &quot;product_id&quot;: &quot;$_id&quot;,
  }},
  
  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
  ]},   
];
</code></pre>
<h2 id="execution-2"><a class="header" href="#execution-2">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.orders.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.orders.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-2"><a class="header" href="#expected-results-2">Expected Results</a></h2>
<p>Four documents should be returned, representing only the four expensive products that were referenced multiple times in the customer orders, each showing the product's total order value and amount sold as shown below:</p>
<pre><code class="language-javascript">[
  {
    product_id: 'pqr88223',
    product: 'Morphy Richardds Food Mixer',
    total_value: NumberDecimal('431.43'),
    quantity: 1
  },
  {
    product_id: 'abc12345',
    product: 'Asus Laptop',
    total_value: NumberDecimal('861.42'),
    quantity: 2
  },
  {
    product_id: 'def45678',
    product: 'Karcher Hose Set',
    total_value: NumberDecimal('67.34'),
    quantity: 3
  },
  {
    product_id: 'xyz11228',
    product: 'Russell Hobbs Chrome Kettle',
    total_value: NumberDecimal('15.76'),
    quantity: 1
  }
]
</code></pre>
<p><em>Note, the order of fields shown for each document may vary.</em></p>
<h2 id="observations-2"><a class="header" href="#observations-2">Observations</a></h2>
<ul>
<li>
<p><strong>Unwinding Arrays.</strong> The <code>$unwind</code> stage is a powerful concept, although often unfamiliar to many developers initially. Distilled down, it does one simple thing: it generates a new record for each element in an array field of every input document. If a source collection has 3 documents and each document contains an array of 4 elements, then performing an <code>$unwind</code> on each record's array field produces 12 records (3 x 4).</p>
</li>
<li>
<p><strong>Introducing A Partial Match</strong>. The current example pipeline scans all documents in the collection and then filters out unpacked products where <code>price &gt; 15.00</code>. If the pipeline executed this filter as the first stage, it would incorrectly produce some result product records with a value of 15 dollars or less. This would be the case for an order composed of both inexpensive and expensive products. However, you can still improve the pipeline by including an additional 'partial match' filter at the start of the pipeline for products valued at over 15 dollars. The aggregation could leverage an index (on <code>products.price</code>), resulting in a partial rather than full collection scan. This extra filter stage is beneficial if the input data set is large and many customer orders are for inexpensive items only. This approach is described in the chapter <a href="examples/simple-examples/../../guides/performance.html">Pipeline Performance Considerations</a>.</p>
</li>
</ul>
<h1 id="strongly-typed-conversion"><a class="header" href="#strongly-typed-conversion">Strongly Typed Conversion</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-3"><a class="header" href="#scenario-3">Scenario</a></h2>
<p>A 3rd party has imported a set of <em>retail orders</em> into a MongoDB collection but with all data typing lost (it stored all field values as strings). You want to re-establish correct typing for all the documents and copy them into a new 'cleaned' collection. You can incorporate such type transformation logic in the aggregation pipeline because you know the type each field had in the original record structure.</p>
<p>Unlike most examples in this book, the aggregation pipeline writes its output to a collection rather than streaming the results back to the calling application.</p>
<h2 id="sample-data-population-3"><a class="header" href="#sample-data-population-3">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>orders</code> collection with three orders documents, where each order has text fields only (note, the second document is intentionality missing the field <code>reported</code> in the sub-document <code>further_info</code>):</p>
<pre><code class="language-javascript">use book-convert-to-strongly-typed;
db.dropDatabase();

// Insert orders documents
db.orders.insertMany([
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;order_date&quot;: &quot;2020-05-30T08:35:52&quot;,
    &quot;value&quot;: &quot;231.43&quot;,
    &quot;further_info&quot;: {
      &quot;item_qty&quot;: &quot;3&quot;,
      &quot;reported&quot;: &quot;false&quot;,
    },
  },
  {
    &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;,
    &quot;order_date&quot;: &quot;2020-01-01T08:25:37&quot;,
    &quot;value&quot;: &quot;63.13&quot;,
    &quot;further_info&quot;: {
      &quot;item_qty&quot;: &quot;2&quot;,
    },
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;order_date&quot;: &quot;2019-05-28T19:13:32&quot;,
    &quot;value&quot;: &quot;2.01&quot;,
    &quot;further_info&quot;: {
      &quot;item_qty&quot;: &quot;1&quot;,
      &quot;reported&quot;: &quot;true&quot;,
    },
  },  
]);
</code></pre>
<h2 id="aggregation-pipeline-3"><a class="header" href="#aggregation-pipeline-3">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Convert strings to required types
  {&quot;$set&quot;: {
    &quot;order_date&quot;: {&quot;$toDate&quot;: &quot;$order_date&quot;},    
    &quot;value&quot;: {&quot;$toDecimal&quot;: &quot;$value&quot;},
    &quot;further_info.item_qty&quot;: {&quot;$toInt&quot;: &quot;$further_info.item_qty&quot;},
    &quot;further_info.reported&quot;: {&quot;$switch&quot;: {
      &quot;branches&quot;: [
        {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$toLower&quot;: &quot;$further_info.reported&quot;}, &quot;true&quot;]}, &quot;then&quot;: true},
        {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$toLower&quot;: &quot;$further_info.reported&quot;}, &quot;false&quot;]}, &quot;then&quot;: false},
      ],
      &quot;default&quot;: {&quot;$ifNull&quot;: [&quot;$further_info.reported&quot;, &quot;$$REMOVE&quot;]},
    }},     
  }},     
  
  // Output to an unsharded or sharded collection
  {&quot;$merge&quot;: {
    &quot;into&quot;: &quot;orders_typed&quot;,
  }},    
];
</code></pre>
<h2 id="execution-3"><a class="header" href="#execution-3">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline to generate and populate a new collection called <code>orders_typed</code>:</p>
<pre><code class="language-javascript">db.orders.aggregate(pipeline);
</code></pre>
<p>Check the contents of the new <code>orders_typed</code> collection to ensure the relevant fields are now appropriately typed:</p>
<pre><code class="language-javascript">db.orders_typed.find();
</code></pre>
<p>View the explain plan for the aggregation pipeline:</p>
<pre><code class="language-javascript">db.orders.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-3"><a class="header" href="#expected-results-3">Expected Results</a></h2>
<p>The same number of documents should appear in the new <code>orders_typed</code> collection as the source collection had, with the same field structure and fields names, but now using strongly typed boolean/date/integer/decimal values where appropriate, as shown below:</p>
<pre><code class="language-javascript">[
  {
    _id: ObjectId('6064381b7aa89666258201fd'),
    customer_id: 'elise_smith@myemail.com',
    further_info: { 
      item_qty: 3, 
      reported: false 
    },
    order_date: ISODate('2020-05-30T08:35:52.000Z'),
    value: NumberDecimal('231.43')
  },
  {
    _id: ObjectId('6064381b7aa89666258201fe'),
    customer_id: 'oranieri@warmmail.com',
    further_info: {
      item_qty: 2 
    },
    order_date: ISODate('2020-01-01T08:25:37.000Z'),
    value: NumberDecimal('63.13')
  },
  {
    _id: ObjectId('6064381b7aa89666258201ff'),
    customer_id: 'tj@wheresmyemail.com',
    further_info: {
      item_qty: 1,
      reported: true
    },
    order_date: ISODate('2019-05-28T19:13:32.000Z'),
    value: NumberDecimal('2.01')
  }
]
</code></pre>
<h2 id="observations-3"><a class="header" href="#observations-3">Observations</a></h2>
<ul>
<li>
<p><strong>Boolean Conversion.</strong> The pipeline's conversions for integers, decimals, and dates are straightforward using the corresponding expression operators, <code>$toInt</code>, <code>$toDecimal</code> and <code>$toDate</code>. However, the expression operator <code>$toBool</code> is not used for the boolean conversion. This is because <code>$toBool</code> will convert any non-empty string to <em>true</em> regardless of its value. As a result, the pipeline uses a <code>$switch</code> operator to compare the lowercase version of strings with the text <code>'true'</code> and <code>'false'</code>, returning the matching boolean.</p>
</li>
<li>
<p><strong>Preserving Non-Existence.</strong> The field <code>further_info.reported</code> is an optional field in this scenario. The field may not always appear in a document, as illustrated by one of the three documents in the example. If a field is not present in a document, this potentially significant fact should never be lost. The pipeline includes additional logic for the <code>further_info.reported</code> field to preserve this information. The pipeline ensures the field is not included in the output document if it didn't exist in the source document. A <code>$ifNull</code> conditional operator is used, which returns the <code>$$REMOVE</code> marker flag if the field is missing, instructing the aggregation engine to omit it.</p>
</li>
<li>
<p><strong>Output To A Collection.</strong> The pipeline uses a <code>$merge</code> stage to instruct the aggregation engine to write the output to a collection rather than returning a stream of results. For this example, the default settings for <code>$merge</code> are sufficient. Each transformed record coming out of the aggregation pipeline becomes a new record in the target collection. The pipeline could have used a <code>$out</code> rather than a <code>$merge</code> stage. However, because <code>$merge</code> supports both unsharded and sharded collections, whereas <code>$out</code> only supports the former, <code>$merge</code> provides a more universally applicable example. If your aggregation needs to create a brand new unsharded collection, <code>$out</code> may be a little faster because the aggregation will completely replace the existing collection if it exists. Using <code>$merge</code>, the system has to perform more checks for every record the aggregation inserts (even though, in this case, it will be to a new collection).</p>
</li>
<li>
<p><strong>Trickier Date Conversions.</strong> In this example, the date strings contain all the date parts required by the <code>$toDate</code> operator to perform a conversion correctly. In some situations, this may not be the case, and a date string may be missing some valuable information (e.g. which century a 2-character year string is for, such as the century <code>19</code> or <code>21</code>). To understand how to deal with these cases, see the <a href="examples/simple-examples/../intricate-examples/convert-incomplete-dates.html">Convert Incomplete Date Strings</a> example chapter.</p>
</li>
</ul>
<h1 id="one-to-one-join"><a class="header" href="#one-to-one-join">One-to-One Join</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.4    <em>(due to use of <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/first-array-element/">$first</a> array operator)</em></p>
<h2 id="scenario-4"><a class="header" href="#scenario-4">Scenario</a></h2>
<p>You want to generate a report to list all shop purchases for 2020, showing the product's name and category for each order, rather than the product's id. To achieve this, you need to take the customer <em>orders</em> collection and join each order record to the corresponding product record in the <em>products</em> collection. There is a many:1 relationship between both collections, resulting in a 1:1 join when matching an order to a product. The join will use a single field comparison between both sides, based on the product's id.</p>
<h2 id="sample-data-population-4"><a class="header" href="#sample-data-population-4">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate new <code>products</code> and <code>orders</code> collections with documents spanning 2019-2021 (the database commands have been split in two to enable your clipboard to hold all the text - ensure you copy and execute each of the two sections):</p>
<p> <strong>-Part 1-</strong></p>
<pre><code class="language-javascript">use book-one-to-one-join;
db.dropDatabase();

// Create index for a products collection
db.products.createIndex({&quot;id&quot;: 1});

// Insert 4 records into the products collection
db.products.insertMany([
  {
    &quot;id&quot;: &quot;a1b2c3d4&quot;,
    &quot;name&quot;: &quot;Asus Laptop&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;Good value laptop for students&quot;,
  },
  {
    &quot;id&quot;: &quot;z9y8x7w6&quot;,
    &quot;name&quot;: &quot;The Day Of The Triffids&quot;,
    &quot;category&quot;: &quot;BOOKS&quot;,
    &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,
  },
  {
    &quot;id&quot;: &quot;ff11gg22hh33&quot;,
    &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;,
    &quot;category&quot;: &quot;KITCHENWARE&quot;,
    &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;,
  },
  {
    &quot;id&quot;: &quot;pqr678st&quot;,
    &quot;name&quot;: &quot;Karcher Hose Set&quot;,
    &quot;category&quot;: &quot;GARDEN&quot;,
    &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;,
  },
]); 
</code></pre>
<p> <strong>-Part 2-</strong></p>
<pre><code class="language-javascript">// Create index for a orders collection
db.orders.createIndex({&quot;orderdate&quot;: -1});

// Insert 4 records into the orders collection
db.orders.insertMany([
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;),
    &quot;product_id&quot;: &quot;a1b2c3d4&quot;,
    &quot;value&quot;: NumberDecimal(&quot;431.43&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;),
    &quot;product_id&quot;: &quot;z9y8x7w6&quot;,
    &quot;value&quot;: NumberDecimal(&quot;5.01&quot;),
  },  
  {
    &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;),
    &quot;product_id&quot;: &quot;ff11gg22hh33&quot;,
    &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;jjones@tepidmail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;),
    &quot;product_id&quot;: &quot;a1b2c3d4&quot;,
    &quot;value&quot;: NumberDecimal(&quot;429.65&quot;),
  },
]);
</code></pre>
<h2 id="aggregation-pipeline-4"><a class="header" href="#aggregation-pipeline-4">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Match only orders made in 2020
  {&quot;$match&quot;: {
    &quot;orderdate&quot;: {
      &quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;),
      &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;),
    }
  }},

  // Join &quot;product_id&quot; in orders collection to &quot;id&quot; in products&quot; collection
  {&quot;$lookup&quot;: {
    &quot;from&quot;: &quot;products&quot;,
    &quot;localField&quot;: &quot;product_id&quot;,
    &quot;foreignField&quot;: &quot;id&quot;,
    &quot;as&quot;: &quot;product_mapping&quot;,
  }},

  // For this data model, will always be 1 record in right-side
  // of join, so take 1st joined array element
  {&quot;$set&quot;: {
    &quot;product_mapping&quot;: {&quot;$first&quot;: &quot;$product_mapping&quot;},
  }},
  
  // Extract the joined embeded fields into top level fields
  {&quot;$set&quot;: {
    &quot;product_name&quot;: &quot;$product_mapping.name&quot;,
    &quot;product_category&quot;: &quot;$product_mapping.category&quot;,
  }},
  
  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;product_id&quot;,
    &quot;product_mapping&quot;,
  ]},     
];
</code></pre>
<h2 id="execution-4"><a class="header" href="#execution-4">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.orders.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.orders.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-4"><a class="header" href="#expected-results-4">Expected Results</a></h2>
<p>Three documents should be returned, representing the three customers orders that occurred in 2020, but with each orders <code>product_id</code> field replaced by two new looked up fields, <code>product_name</code> and <code>product_category</code>, as shown below:</p>
<pre><code class="language-javascript">[
  {
    customer_id: 'elise_smith@myemail.com',
    orderdate: ISODate('2020-05-30T08:35:52.000Z'),
    value: NumberDecimal('431.43'),
    product_name: 'Asus Laptop',
    product_category: 'ELECTRONICS'
  },
  {
    customer_id: 'oranieri@warmmail.com',
    orderdate: ISODate('2020-01-01T08:25:37.000Z'),
    value: NumberDecimal('63.13'),
    product_name: 'Morphy Richardds Food Mixer',
    product_category: 'KITCHENWARE'
  },
  {
    customer_id: 'jjones@tepidmail.com',
    orderdate: ISODate('2020-12-26T08:55:46.000Z'),
    value: NumberDecimal('429.65'),
    product_name: 'Asus Laptop',
    product_category: 'ELECTRONICS'
  }
]
</code></pre>
<h2 id="observations-4"><a class="header" href="#observations-4">Observations</a></h2>
<ul>
<li>
<p><strong>Single Field Match.</strong> The pipeline includes a <code>$lookup</code> join between a single field from each collection. For an illustration of performing a join based on two or more matching fields, see the <a href="examples/simple-examples/../moderate-examples/multi-one-to-many.html">Multi-Field Join &amp; One-to-Many</a> example.</p>
</li>
<li>
<p><strong>First Element Assumption.</strong> In this particular data model example, the join between the two collections is 1:1. Therefore the returned array of joined elements coming out of the <code>$lookup</code> stage always contains precisely one array element. As a result, the pipeline extracts the data from this first array element only, using the <code>$first</code> operator. For an illustration of performing a 1:many join instead, see the <a href="examples/simple-examples/../moderate-examples/multi-one-to-many.html">Multi-Field Join &amp; One-to-Many</a> example.</p>
</li>
</ul>
<h1 id="moderate-examples"><a class="header" href="#moderate-examples">Moderate Examples</a></h1>
<p>This section provides examples for using the Aggregation Framework to solve common data manipulation challenges where the examples are a little more challenging to understand and adapt.</p>
<h1 id="multi-field-join--one-to-many"><a class="header" href="#multi-field-join--one-to-many">Multi-Field Join &amp; One-to-Many</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-5"><a class="header" href="#scenario-5">Scenario</a></h2>
<p>You want to generate a report to list all the orders made for each product in 2020. To achieve this, you need to take a shop's <em>products</em> collection and join each product record to all its orders stored in an <em>orders</em> collection. There is a 1:many relationship between both collections, based on a match of two fields on each side. Rather than joining on a single field like <code>product_id</code> (which doesn't exist in this data set), you need to use two common fields to join (<code>product_name</code> and <code>product_variation</code>). </p>
<p>Note that the requirement to perform a 1:many join does not mandate the need to join by multiple fields on each side of the join. However, in this example, it has been deemed beneficial to show both of these aspects in one place.</p>
<h2 id="sample-data-population-5"><a class="header" href="#sample-data-population-5">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate new <code>products</code> and <code>orders</code> collections with documents spanning 2019-2021 (the database commands have been split in two to enable your clipboard to hold all the text - ensure you copy and execute each of the two sections):</p>
<p> <strong>-Part 1-</strong></p>
<pre><code class="language-javascript">use book-multi-one-to-many;
db.dropDatabase();

// Insert 6 records into the products collection
db.products.insertMany([
  {
    &quot;name&quot;: &quot;Asus Laptop&quot;,
    &quot;variation&quot;: &quot;Ultra HD&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;Great for watching movies&quot;,
  },
  {
    &quot;name&quot;: &quot;Asus Laptop&quot;,
    &quot;variation&quot;: &quot;Normal Display&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;Good value laptop for students&quot;,
  },
  {
    &quot;name&quot;: &quot;The Day Of The Triffids&quot;,
    &quot;variation&quot;: &quot;1st Edition&quot;,
    &quot;category&quot;: &quot;BOOKS&quot;,
    &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,
  },
  {
    &quot;name&quot;: &quot;The Day Of The Triffids&quot;,
    &quot;variation&quot;: &quot;2nd Edition&quot;,
    &quot;category&quot;: &quot;BOOKS&quot;,
    &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,
  },
  {
    &quot;name&quot;: &quot;Morphy Richards Food Mixer&quot;,
    &quot;variation&quot;: &quot;Deluxe&quot;,
    &quot;category&quot;: &quot;KITCHENWARE&quot;,
    &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;,
  },
  {
    &quot;name&quot;: &quot;Karcher Hose Set&quot;,
    &quot;variation&quot;: &quot;Full Monty&quot;,
    &quot;category&quot;: &quot;GARDEN&quot;,
    &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;,
  },
]); 
</code></pre>
<p> <strong>-Part 2-</strong></p>
<pre><code class="language-javascript">// Create index for the orders collection
db.orders.createIndex({&quot;product_name&quot;: 1, &quot;product_variation&quot;: 1});

// Insert 4 records into the orders collection
db.orders.insertMany([
  {
    &quot;customer_id&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-05-30T08:35:52Z&quot;),
    &quot;product_name&quot;: &quot;Asus Laptop&quot;,
    &quot;product_variation&quot;: &quot;Normal Display&quot;,
    &quot;value&quot;: NumberDecimal(&quot;431.43&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2019-05-28T19:13:32Z&quot;),
    &quot;product_name&quot;: &quot;The Day Of The Triffids&quot;,
    &quot;product_variation&quot;: &quot;2nd Edition&quot;,
    &quot;value&quot;: NumberDecimal(&quot;5.01&quot;),
  },  
  {
    &quot;customer_id&quot;: &quot;oranieri@warmmail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-01-01T08:25:37Z&quot;),
    &quot;product_name&quot;: &quot;Morphy Richards Food Mixer&quot;,
    &quot;product_variation&quot;: &quot;Deluxe&quot;,
    &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),
  },
  {
    &quot;customer_id&quot;: &quot;jjones@tepidmail.com&quot;,
    &quot;orderdate&quot;: ISODate(&quot;2020-12-26T08:55:46Z&quot;),
    &quot;product_name&quot;: &quot;Asus Laptop&quot;,
    &quot;product_variation&quot;: &quot;Normal Display&quot;,
    &quot;value&quot;: NumberDecimal(&quot;429.65&quot;),
  },
]);
</code></pre>
<h2 id="aggregation-pipeline-5"><a class="header" href="#aggregation-pipeline-5">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Join by 2 fields in in products collection to 2 fields in orders collection
  {&quot;$lookup&quot;: {
    &quot;from&quot;: &quot;orders&quot;,
    &quot;let&quot;: {
      &quot;prdname&quot;: &quot;$name&quot;,
      &quot;prdvartn&quot;: &quot;$variation&quot;,
    },
    // Embedded pipeline to control how the join is matched
    &quot;pipeline&quot;: [
      // Join by two fields in each side
      {&quot;$match&quot;:
        {&quot;$expr&quot;:
          {&quot;$and&quot;: [
            {&quot;$eq&quot;: [&quot;$product_name&quot;,  &quot;$$prdname&quot;]},
            {&quot;$eq&quot;: [&quot;$product_variation&quot;,  &quot;$$prdvartn&quot;]},            
          ]},
        },
      },

      // Match only orders made in 2020
      {&quot;$match&quot;: {
        &quot;orderdate&quot;: {
          &quot;$gte&quot;: ISODate(&quot;2020-01-01T00:00:00Z&quot;),
          &quot;$lt&quot;: ISODate(&quot;2021-01-01T00:00:00Z&quot;),
        }
      }},
      
      // Exclude some unwanted fields from the right side of the join
      {&quot;$unset&quot;: [
        &quot;_id&quot;,
        &quot;product_name&quot;,
        &quot;product_variation&quot;,
      ]},
    ],
    as: &quot;orders&quot;,
  }},

  // Only show products that have at least one order
  {&quot;$match&quot;: {
    &quot;orders&quot;: {&quot;$ne&quot;: []},
  }},

  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
  ]}, 
];
</code></pre>
<h2 id="execution-5"><a class="header" href="#execution-5">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.products.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.products.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-5"><a class="header" href="#expected-results-5">Expected Results</a></h2>
<p>Two documents should be returned, representing the two products that had one or more orders in 2020, with the orders embedded in an array against each product, as shown below:</p>
<pre><code class="language-javascript">[
  {
    name: 'Asus Laptop',
    variation: 'Normal Display',
    category: 'ELECTRONICS',
    description: 'Good value laptop for students',
    orders: [
      {
        customer_id: 'elise_smith@myemail.com',
        orderdate: ISODate('2020-05-30T08:35:52.000Z'),
        value: NumberDecimal('431.43')
      },
      {
        customer_id: 'jjones@tepidmail.com',
        orderdate: ISODate('2020-12-26T08:55:46.000Z'),
        value: NumberDecimal('429.65')
      }
    ]
  },
  {
    name: 'Morphy Richards Food Mixer',
    variation: 'Deluxe',
    category: 'KITCHENWARE',
    description: 'Luxury mixer turning good cakes into great',
    orders: [
      {
        customer_id: 'oranieri@warmmail.com',
        orderdate: ISODate('2020-01-01T08:25:37.000Z'),
        value: NumberDecimal('63.13')
      }
    ]
  }
]
</code></pre>
<h2 id="observations-5"><a class="header" href="#observations-5">Observations</a></h2>
<ul>
<li>
<p><strong>Multiple Join Fields.</strong> To perform a join of two or more fields between the two collections, you need to use a <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/lookup/#join-conditions-and-uncorrelated-sub-queries">let</a> parameter rather than specifying the <code>localField</code> and <code>foreignField</code> parameters used in a single field join. With a <code>let</code> parameter, you bind multiple fields from the first collection into variables ready to be used in the joining process. You use an embedded <code>pipeline</code> inside the <code>$lookup</code> stage to match the <em>bind</em> variables with fields in the second collection's records. In this instance, the<code>$expr</code> operator's comparison can leverage an index because only equality matches are employed.</p>
</li>
<li>
<p><strong>Reducing Array Content.</strong> The presence of an embedded pipeline in the <code>$lookup</code> stage provides an opportunity to filter out three unwanted fields brought in from the second collection. Instead, you could use an <code>$unset</code> stage later in the top-level pipeline to project out these unwanted array elements. If you need to perform more complex array content filtering rules, you can use the approach described in section &quot;<em>2. Avoid Unwinding &amp; Regrouping Documents Just To Process Array Elements</em>&quot; of the chapter <a href="examples/moderate-examples/../../guides/performance.html">Pipeline Performance Considerations</a>.</p>
</li>
</ul>
<h1 id="faceted-classification"><a class="header" href="#faceted-classification">Faceted Classification</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-6"><a class="header" href="#scenario-6">Scenario</a></h2>
<p>You want to provide a <a href="https://en.wikipedia.org/wiki/Faceted_search">faceted search</a> capability on your retail website to enable customers to refine their product search by selecting specific characteristics against the product results listed in the web page. It is beneficial to classify the products by different dimensions, where each dimension, or facet, corresponds to a particular field in a product record (e.g. <em>product rating</em>, <em>product price</em>). Each facet should be broken down into sub-ranges so that a customer can select a specific sub-range (<em>4 - 5 stars</em>) for a particular facet (e.g. <em>rating</em>). The aggregation pipeline will analyse the <em>products</em> collection by each facet's field (<em>rating</em> and <em>price</em>) to determine each facet's spread of values.</p>
<h2 id="sample-data-population-6"><a class="header" href="#sample-data-population-6">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>products</code> collection with 16 documents (the database commands have been split in two to enable your clipboard to hold all the text - ensure you copy and execute each of the two sections):</p>
<p> <strong>-Part 1-</strong></p>
<pre><code class="language-javascript">use book-faceted-classfctn;
db.dropDatabase();

// Insert first 8 records into the collection
db.products.insertMany([
  {
    &quot;name&quot;: &quot;Asus Laptop&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;Good value laptop for students&quot;,
    &quot;price&quot;: NumberDecimal(&quot;431.43&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.2&quot;),
  },
  {
    &quot;name&quot;: &quot;The Day Of The Triffids&quot;,
    &quot;category&quot;: &quot;BOOKS&quot;,
    &quot;description&quot;: &quot;Classic post-apocalyptic novel&quot;,
    &quot;price&quot;: NumberDecimal(&quot;5.01&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.8&quot;),
  },
  {
    &quot;name&quot;: &quot;Morphy Richardds Food Mixer&quot;,
    &quot;category&quot;: &quot;KITCHENWARE&quot;,
    &quot;description&quot;: &quot;Luxury mixer turning good cakes into great&quot;,
    &quot;price&quot;: NumberDecimal(&quot;63.13&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;3.8&quot;),
  },
  {
    &quot;name&quot;: &quot;Karcher Hose Set&quot;,
    &quot;category&quot;: &quot;GARDEN&quot;,
    &quot;description&quot;: &quot;Hose + nosels + winder for tidy storage&quot;,
    &quot;price&quot;: NumberDecimal(&quot;22.13&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.3&quot;),
  },
  {
    &quot;name&quot;: &quot;Oak Coffee Table&quot;,
    &quot;category&quot;: &quot;HOME&quot;,
    &quot;description&quot;: &quot;size is 2m x 0.5m x 0.4m&quot;,
    &quot;price&quot;: NumberDecimal(&quot;22.13&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;3.8&quot;),
  },
  {
    &quot;name&quot;: &quot;Lenovo Laptop&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;High spec good for gaming&quot;,
    &quot;price&quot;: NumberDecimal(&quot;1299.99&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.1&quot;),
  },
  {
    &quot;name&quot;: &quot;One Day in the Life of Ivan Denisovich&quot;,
    &quot;category&quot;: &quot;BOOKS&quot;,
    &quot;description&quot;: &quot;Brutal life in a labour camp&quot;,
    &quot;price&quot;: NumberDecimal(&quot;4.29&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.9&quot;),
  },
  {
    &quot;name&quot;: &quot;Russell Hobbs Chrome Kettle&quot;,
    &quot;category&quot;: &quot;KITCHENWARE&quot;,
    &quot;description&quot;: &quot;Nice looking budget kettle&quot;,
    &quot;price&quot;: NumberDecimal(&quot;15.76&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;3.9&quot;),
  },
]);   
</code></pre>
<p> <strong>-Part 2-</strong></p>
<pre><code class="language-javascript">// Insert second 8 records into the collection
db.products.insertMany([  
  {
    &quot;name&quot;: &quot;Tiffany Gold Chain&quot;,
    &quot;category&quot;: &quot;JEWELERY&quot;,
    &quot;description&quot;: &quot;Looks great for any age and gender&quot;,
    &quot;price&quot;: NumberDecimal(&quot;582.22&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.0&quot;),
  },
  {
    &quot;name&quot;: &quot;Raleigh Racer 21st Century Classic&quot;,
    &quot;category&quot;: &quot;BICYCLES&quot;,
    &quot;description&quot;: &quot;Modern update to a classic 70s bike design&quot;,
    &quot;price&quot;: NumberDecimal(&quot;523.00&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.5&quot;),
  },
  {
    &quot;name&quot;: &quot;Diesel Flare Jeans&quot;,
    &quot;category&quot;: &quot;CLOTHES&quot;,
    &quot;description&quot;: &quot;Top end casual look&quot;,
    &quot;price&quot;: NumberDecimal(&quot;129.89&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.3&quot;),
  },
  {
    &quot;name&quot;: &quot;Jazz Silk Scarf&quot;,
    &quot;category&quot;: &quot;CLOTHES&quot;,
    &quot;description&quot;: &quot;Style for the winder months&quot;,
    &quot;price&quot;: NumberDecimal(&quot;28.39&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;3.7&quot;),
  },
  {
    &quot;name&quot;: &quot;Dell XPS 13 Laptop&quot;,
    &quot;category&quot;: &quot;ELECTRONICS&quot;,
    &quot;description&quot;: &quot;Developer edition&quot;,
    &quot;price&quot;: NumberDecimal(&quot;1399.89&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.4&quot;),
  },
  {
    &quot;name&quot;: &quot;NY Baseball Cap&quot;,
    &quot;category&quot;: &quot;CLOTHES&quot;,
    &quot;description&quot;: &quot;Blue &amp; white&quot;,
    &quot;price&quot;: NumberDecimal(&quot;18.99&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.0&quot;),
  },
  {
    &quot;name&quot;: &quot;Tots Flower Pots&quot;,
    &quot;category&quot;: &quot;GARDEN&quot;,
    &quot;description&quot;: &quot;Set of three&quot;,
    &quot;price&quot;: NumberDecimal(&quot;9.78&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;4.1&quot;),
  },  
  {
    &quot;name&quot;: &quot;Picky Pencil Sharpener&quot;,
    &quot;category&quot;: &quot;Stationery&quot;,
    &quot;description&quot;: &quot;Ultra budget&quot;,
    &quot;price&quot;: NumberDecimal(&quot;0.67&quot;),
    &quot;rating&quot;: NumberDecimal(&quot;1.2&quot;),
  },  
]); 
</code></pre>
<h2 id="aggregation-pipeline-6"><a class="header" href="#aggregation-pipeline-6">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Group products by 2 facets: 1) by price ranges, 2) by rating ranges
  {&quot;$facet&quot;: {

    // Group by price ranges
    &quot;by_price&quot;: [
      // Group into 3 ranges: inexpensive small price range to expensive large price range
      {&quot;$bucketAuto&quot;: {
        &quot;groupBy&quot;: &quot;$price&quot;,
        &quot;buckets&quot;: 3,
        &quot;granularity&quot;: &quot;1-2-5&quot;,
        &quot;output&quot;: {
          &quot;count&quot;: {&quot;$sum&quot;: 1},
          &quot;products&quot;: {&quot;$push&quot;: &quot;$name&quot;},
        },
      }},
      
      // Tag range info as &quot;price_range&quot;
      {&quot;$set&quot;: {
        &quot;price_range&quot;: &quot;$_id&quot;,
      }},         
      
      // Omit unwanted fields
      {&quot;$unset&quot;: [
        &quot;_id&quot;,
      ]},         
    ],

    // Group by rating ranges
    &quot;by_rating&quot;: [
      // Group products evenly across 5 rating ranges from low to high
      {&quot;$bucketAuto&quot;: {
        &quot;groupBy&quot;: &quot;$rating&quot;,
        &quot;buckets&quot;: 5,
        &quot;output&quot;: {
          &quot;count&quot;: {&quot;$sum&quot;: 1},
          &quot;products&quot;: {&quot;$push&quot;: &quot;$name&quot;},
        },
      }},
      
      // Tag range info as &quot;rating_range&quot;
      {&quot;$set&quot;: {
        &quot;rating_range&quot;: &quot;$_id&quot;,
      }},         
      
      // Omit unwanted fields
      {&quot;$unset&quot;: [
        &quot;_id&quot;,
      ]},         
    ],
  }},  
];
</code></pre>
<h2 id="execution-6"><a class="header" href="#execution-6">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.products.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.products.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-6"><a class="header" href="#expected-results-6">Expected Results</a></h2>
<p>A single document should be returned, which contains 2 facets (keyed off <code>by_price</code> and <code>by_rating</code> respectively), where each facet shows its sub-ranges of values and the products belonging to each sub-range, as shown below:</p>
<pre><code class="language-javascript">[
  {
    by_price: [
      {
        count: 6,
        products: [
          'Picky Pencil Sharpener', 'One Day in the Life of Ivan Denisovich', 
          'The Day Of The Triffids', 'Tots Flower Pots', 'Russell Hobbs Chrome Kettle',
          'NY Baseball Cap'
        ],
        price_range: {
          min: NumberDecimal('0.500000000000000'), max: NumberDecimal('20.0000000000000')
        }
      },
      {
        count: 5,
        products: [
          'Karcher Hose Set', 'Oak Coffee Table', 'Jazz Silk Scarf',
          'Morphy Richardds Food Mixer', 'Diesel Flare Jeans'
        ],
        price_range: {
          min: NumberDecimal('20.0000000000000'), max: NumberDecimal('200.0000000000000')
        }
      },
      {
        count: 5,
        products: [
          'Asus Laptop', 'Raleigh Racer 21st Century Classic', 'Tiffany Gold Chain',
          'Lenovo Laptop', 'Dell XPS 13 Laptop'
        ],
        price_range: {
          min: NumberDecimal('200.0000000000000'), max: NumberDecimal('2000.0000000000000')
        }
      }
    ],
    by_rating: [
      {
        count: 4,
        products: [
          'Picky Pencil Sharpener', 'Jazz Silk Scarf', 'Morphy Richardds Food Mixer',
          'Oak Coffee Table'
        ],
        rating_range: { min: NumberDecimal('1.2'), max: NumberDecimal('3.9') }
      },
      {
        count: 3,
        products: [
          'Russell Hobbs Chrome Kettle', 'Tiffany Gold Chain', 'NY Baseball Cap'
        ],
        rating_range: { min: NumberDecimal('3.9'), max: NumberDecimal('4.1') }
      },
      {
        count: 3,
        products: [ 'Lenovo Laptop', 'Tots Flower Pots', 'Asus Laptop' ],
        rating_range: { min: NumberDecimal('4.1'), max: NumberDecimal('4.3') }
      },
      {
        count: 3,
        products: [
          'Karcher Hose Set', 'Diesel Flare Jeans', 'Dell XPS 13 Laptop'
        ],
        rating_range: { min: NumberDecimal('4.3'), max: NumberDecimal('4.5') }
      },
      {
        count: 3,
        products: [
          'Raleigh Racer 21st Century Classic', 'The Day Of The Triffids',
          'One Day in the Life of Ivan Denisovich'
        ],
        rating_range: { min: NumberDecimal('4.5'), max: NumberDecimal('4.9') }
      }
    ]
  }
]
</code></pre>
<h2 id="observations-6"><a class="header" href="#observations-6">Observations</a></h2>
<ul>
<li>
<p><strong>Multiple Pipelines.</strong> The <code>$facet</code> stage doesn't have to be employed for you to use the <code>$bucketAuto</code> stage. In most <em>faceted search</em> scenarios, you will want to understand a collection by multiple dimensions at once (<em>price</em> &amp; <em>rating</em> in this case). The <code>$facet</code> stage is convenient because it allows you to define various <code>$bucketAuto</code> dimensions in one go in a single pipeline. Otherwise, a client application must invoke an aggregation multiple times, each using a new <code>$bucketAuto</code> stage to process a different field. In fact, each section of a <code>$facet</code> stage is just a regular aggregation [sub-]pipeline, able to contain any type of stage (with a few specific <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/facet/#behavior">documented exceptions</a>) and may not even contain <code>$bucketAuto</code> or <code>$bucket</code> stages at all. </p>
</li>
<li>
<p><strong>Single Document Result.</strong> If the result of a <code>$facet</code> based aggregation is allowed to be multiple documents, this will cause a problem. The results will contain a mix of records originating from different facets but with no way of ascertaining the facet each result record belongs to. Consequently, when using <code>$facet</code>, a single document is always returned, containing top-level fields identifying each facet. Having only a single result record is not usually a problem. A typical requirement for faceted search is to return a small amount of grouped summary data about a collection rather than large amounts of raw data from the collection. Therefore the 16MB document size limit should not be an issue.</p>
</li>
<li>
<p><strong>Spread Of Ranges.</strong> In this example, each of the two employed bucketing facets uses a different granularity number scheme for spreading out the sub-ranges of values. You choose a numbering scheme based on what you know about the nature of the facet. For instance, most of the <em>ratings</em> values in the sample collection have scores bunched between late 3s and early 4s. If a numbering scheme is defined to reflect an even spread of ratings, most products will appear in the same sub-range bucket and some sub-ranges would contain no products (e.g. ratings 2 to 3 in this example). This wouldn't provide website customers with much selectivity on product ratings.</p>
</li>
</ul>
<h1 id="restricted-view"><a class="header" href="#restricted-view">Restricted View</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-7"><a class="header" href="#scenario-7">Scenario</a></h2>
<p>You have a <em>persons</em> collection, where a particular client application shouldn't be allowed to see sensitive information. Consequently, you will provide a read-only view of a filtered subset of peoples' data only. In a real-world situation, you would also use MongoDB's Role-Based Access Control (RBAC) to limit the client application to only be able to access the view and not the original collection. You will use the view (named <em>adults</em>) to restrict the personal data for the client application in two ways:</p>
<ol>
<li>Only show people aged 18 and over (by checking each person's <code>dateofbirth</code> field)</li>
<li>Exclude each person's <code>social_security_num</code> field from results</li>
</ol>
<p>Essentially, this is an illustration of achieving 'record-level' access control in MongoDB.</p>
<h2 id="sample-data-population-7"><a class="header" href="#sample-data-population-7">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists), create an index and populate the new <code>persons</code> collections with 5 records:</p>
<pre><code class="language-javascript">use book-restricted-view;
db.dropDatabase();

// Create indexes for a persons collection
db.persons.createIndex({&quot;gender&quot;: 1});
db.persons.createIndex({&quot;dateofbirth&quot;: -1});

// Insert records into the persons collection
db.persons.insertMany([
  {
    &quot;person_id&quot;: &quot;6392529400&quot;,
    &quot;firstname&quot;: &quot;Elise&quot;,
    &quot;lastname&quot;: &quot;Smith&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1972-01-13T09:32:07Z&quot;),
    &quot;gender&quot;: &quot;FEMALE&quot;,
    &quot;email&quot;: &quot;elise_smith@myemail.com&quot;,
    &quot;social_security_num&quot;: &quot;507-28-9805&quot;,
    &quot;address&quot;: { 
        &quot;number&quot;: 5625,
        &quot;street&quot;: &quot;Tipa Circle&quot;,
        &quot;city&quot;: &quot;Wojzinmoj&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;1723338115&quot;,
    &quot;firstname&quot;: &quot;Olive&quot;,
    &quot;lastname&quot;: &quot;Ranieri&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1985-05-12T23:14:30Z&quot;),    
    &quot;gender&quot;: &quot;FEMALE&quot;,
    &quot;email&quot;: &quot;oranieri@warmmail.com&quot;,
    &quot;social_security_num&quot;: &quot;618-71-2912&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 9303,
        &quot;street&quot;: &quot;Mele Circle&quot;,
        &quot;city&quot;: &quot;Tobihbo&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;8732762874&quot;,
    &quot;firstname&quot;: &quot;Toni&quot;,
    &quot;lastname&quot;: &quot;Jones&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;2014-11-23T16:53:56Z&quot;),    
    &quot;gender&quot;: &quot;FEMALE&quot;,
    &quot;email&quot;: &quot;tj@wheresmyemail.com&quot;,
    &quot;social_security_num&quot;: &quot;001-10-3488&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 1,
        &quot;street&quot;: &quot;High Street&quot;,
        &quot;city&quot;: &quot;Upper Abbeywoodington&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;7363629563&quot;,
    &quot;firstname&quot;: &quot;Bert&quot;,
    &quot;lastname&quot;: &quot;Gooding&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;1941-04-07T22:11:52Z&quot;),    
    &quot;gender&quot;: &quot;MALE&quot;,
    &quot;email&quot;: &quot;bgooding@tepidmail.com&quot;,
    &quot;social_security_num&quot;: &quot;230-43-7633&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 13,
        &quot;street&quot;: &quot;Upper Bold Road&quot;,
        &quot;city&quot;: &quot;Redringtonville&quot;,
    },
  },
  {
    &quot;person_id&quot;: &quot;1029648329&quot;,
    &quot;firstname&quot;: &quot;Sophie&quot;,
    &quot;lastname&quot;: &quot;Celements&quot;,
    &quot;dateofbirth&quot;: ISODate(&quot;2013-07-06T17:35:45Z&quot;),    
    &quot;gender&quot;: &quot;FEMALE&quot;,
    &quot;email&quot;: &quot;sophe@celements.net&quot;,
    &quot;social_security_num&quot;: &quot;377-30-5364&quot;,
    &quot;address&quot;: {
        &quot;number&quot;: 5,
        &quot;street&quot;: &quot;Innings Close&quot;,
        &quot;city&quot;: &quot;Basilbridge&quot;,
    },
  },
]);
</code></pre>
<h2 id="aggregation-pipeline-7"><a class="header" href="#aggregation-pipeline-7">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Filter out any persons aged under 18 ($expr required to reference '$$NOW')
  {&quot;$match&quot;:
    {&quot;$expr&quot;:{
      &quot;$lt&quot;: [&quot;$dateofbirth&quot;, {&quot;$subtract&quot;: [&quot;$$NOW&quot;, 18*365.25*24*60*60*1000]}]
    }},
  },

  // Exclude fields to be filtered out by the view
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;social_security_num&quot;,
  ]},    
];
</code></pre>
<h2 id="execution-7"><a class="header" href="#execution-7">Execution</a></h2>
<p>Firstly, to test the defined aggregation pipeline (before using it to create a view), execute the aggregation for the pipeline and also observe its explain plan:</p>
<pre><code class="language-javascript">db.persons.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.persons.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<p>Now create the new <em>adults</em> view, which will automatically apply the aggregation pipeline whenever anyone queries the view: </p>
<pre><code class="language-javascript">db.createView(&quot;adults&quot;, &quot;persons&quot;, pipeline);
</code></pre>
<p>Execute a regular MQL query against the view, without any filter criteria, and also observe its explain plan:</p>
<pre><code class="language-javascript">db.adults.find();
</code></pre>
<pre><code class="language-javascript">db.adults.explain(&quot;executionStats&quot;).find();
</code></pre>
<p>Execute a MQL query against the view, but this time with a filter to return only adults who are female, and again observe its explain plan to see how the <code>gender</code> filter affects the plan:</p>
<pre><code class="language-javascript">db.adults.find({&quot;gender&quot;: &quot;FEMALE&quot;});
</code></pre>
<pre><code class="language-javascript">db.adults.explain(&quot;executionStats&quot;).find({&quot;gender&quot;: &quot;FEMALE&quot;});
</code></pre>
<h2 id="expected-results-7"><a class="header" href="#expected-results-7">Expected Results</a></h2>
<p>The result for both the <code>aggregate()</code> command and the <code>find()</code> executed on the <em>view</em> should be the same, with three documents returned, representing the three persons who are over 18 but not showing their actual dates of birth, as shown below:</p>
<pre><code class="language-javascript">[
  {
    person_id: '6392529400',
    firstname: 'Elise',
    lastname: 'Smith',
    dateofbirth: ISODate('1972-01-13T09:32:07.000Z'),
    gender: 'FEMALE',
    email: 'elise_smith@myemail.com',
    address: { number: 5625, street: 'Tipa Circle', city: 'Wojzinmoj' }
  },
  {
    person_id: '1723338115',
    firstname: 'Olive',
    lastname: 'Ranieri',
    dateofbirth: ISODate('1985-05-12T23:14:30.000Z'),
    gender: 'FEMALE',
    email: 'oranieri@warmmail.com',
    address: { number: 9303, street: 'Mele Circle', city: 'Tobihbo' }
  },
  {
    person_id: '7363629563',
    firstname: 'Bert',
    lastname: 'Gooding',
    dateofbirth: ISODate('1941-04-07T22:11:52.000Z'),
    gender: 'MALE',
    email: 'bgooding@tepidmail.com',
    address: { number: 13, street: 'Upper Bold Road', city: 'Redringtonville' }
  }
]
</code></pre>
<p>The result of running the <code>find()</code> against the <em>view</em> with the filter <code>&quot;gender&quot;: &quot;FEMALE&quot;</code> should be two females records only because the male record has been excluded, as shown below:</p>
<pre><code class="language-javascript">[
  {
    person_id: '6392529400',
    firstname: 'Elise',
    lastname: 'Smith',
    dateofbirth: ISODate('1972-01-13T09:32:07.000Z'),
    gender: 'FEMALE',
    email: 'elise_smith@myemail.com',
    address: { number: 5625, street: 'Tipa Circle', city: 'Wojzinmoj' }
  },
  {
    person_id: '1723338115',
    firstname: 'Olive',
    lastname: 'Ranieri',
    dateofbirth: ISODate('1985-05-12T23:14:30.000Z'),
    gender: 'FEMALE',
    email: 'oranieri@warmmail.com',
    address: { number: 9303, street: 'Mele Circle', city: 'Tobihbo' }
  }
]
</code></pre>
<h2 id="observations-7"><a class="header" href="#observations-7">Observations</a></h2>
<ul>
<li>
<p><strong>Expr &amp; Indexes.</strong> The <a href="https://docs.mongodb.com/manual/reference/aggregation-variables/">'NOW' system variable</a> used here returns the current system date-time. However, you can only access this system variable via an <a href="https://docs.mongodb.com/manual/meta/aggregation-quick-reference/#expressions">aggregation expression</a> and not directly via the normal MongoDB query syntax used by MQL and <code>$match</code>. You must wrap an expression using <code>$$NOW</code> inside an <code>$expr</code> operator. As described in the chapter <a href="examples/moderate-examples/../../guides/expressions.html">Can Expressions Be Used Everywhere?</a>, if you use an <a href="https://docs.mongodb.com/manual/reference/operator/query/expr/">$expr query operator</a> to perform a range comparison, you can't make use of an index (which is the case for <code>dateofbirth</code> here). For a view, because the pipeline is 'statically' defined when creating the view, you cannot obtain the current date-time at runtime by other means.</p>
</li>
<li>
<p><strong>View Finds &amp; Indexes.</strong> The explain plan for the <em>gender query</em> run against the <em>view</em> shows an index has been used (the index defined for the <code>gender</code> field). At runtime, a view is essentially just an aggregation pipeline defined 'ahead of time'. When <code>db.adults.find({&quot;gender&quot;: &quot;FEMALE&quot;})</code> is executed, the database engine dynamically appends a new <code>$match</code> stage to the end of the pipeline for the gender match. It then optimises the pipeline by moving the new <code>$match</code> stage to the pipeline's start. Finally, it adds the filter extracted from the new <code>$match</code> stage to the aggregation's initial query and hence the <code>gender</code> index is leveraged. The following two excerpts from the explain plan illustrate how the filter on <code>gender</code> and the filter on <code>dateofbirth</code> combine at runtime and how the index for <code>gender</code> is used to avoid a full collection scan:</p>
</li>
</ul>
<pre><code class="language-javascript">'$cursor': {
  queryPlanner: {
    plannerVersion: 1,
    namespace: 'book-restricted-view.persons',
    indexFilterSet: false,
    parsedQuery: {
      '$and': [
        { gender: { '$eq': 'FEMALE' } },
        {
          '$expr': {
            '$lt': [
              '$dateofbirth',
              {
                '$subtract': [ '$$NOW', { '$const': 568036800000 } ]
</code></pre>
<pre><code class="language-javascript">inputStage: {
  stage: 'IXSCAN',
  keyPattern: { gender: 1 },
  indexName: 'gender_1',
  direction: 'forward',
  indexBounds: { gender: [ '[&quot;FEMALE&quot;, &quot;FEMALE&quot;]' ] }
}
</code></pre>
<ul>
<li><strong>Further Reading.</strong> The ability for <em>find</em> operations on a view to automatically push filters into the view's aggregation pipeline, and then be further optimised, is described in the blog post: <a href="https://pauldone.blogspot.com/2020/11/mongdb-views-optimisations.html">Is Querying A MongoDB View Optimised?</a></li>
</ul>
<h1 id="largest-graph-network"><a class="header" href="#largest-graph-network">Largest Graph Network</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-8"><a class="header" href="#scenario-8">Scenario</a></h2>
<p>Your organisation wants to know the best targets for a new marketing campaign based on a social network database similar to <em>Twitter</em>. You want to search the collection of social network users, each holding a user's name and the names of other people who follow them. You will execute an aggregation pipeline that walks each user record's <code>followed_by</code> array to determine which user has the largest <em>network reach</em>.</p>
<p>Note this example uses a simple data model for brevity. However, this is unlikely to be an optimum data model for using <code>$graphLookup</code> at scale for social network users with many followers or running in a sharded environment. For more guidance on such matters, see this reference application: <a href="https://github.com/mongodb-labs/socialite">Socialite</a></p>
<h2 id="sample-data-population-8"><a class="header" href="#sample-data-population-8">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>users</code> collection with 10 social network users documents, plus an index to help optimise the <em>graph traversal</em>:</p>
<pre><code class="language-javascript">use book-largest-graph-network;
db.dropDatabase();

// Create index on field which for each graph traversal hop will connect to
db.users.createIndex({&quot;name&quot;: 1})

// Insert records into the users collection
db.users.insertMany([
  {&quot;name&quot;: &quot;Paul&quot;, &quot;followed_by&quot;: []},
  {&quot;name&quot;: &quot;Toni&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;]},
  {&quot;name&quot;: &quot;Janet&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;, &quot;Toni&quot;]},
  {&quot;name&quot;: &quot;David&quot;, &quot;followed_by&quot;: [&quot;Janet&quot;, &quot;Paul&quot;, &quot;Toni&quot;]},
  {&quot;name&quot;: &quot;Fiona&quot;, &quot;followed_by&quot;: [&quot;David&quot;, &quot;Paul&quot;]},
  {&quot;name&quot;: &quot;Bob&quot;, &quot;followed_by&quot;: [&quot;Janet&quot;]},
  {&quot;name&quot;: &quot;Carl&quot;, &quot;followed_by&quot;: [&quot;Fiona&quot;]},
  {&quot;name&quot;: &quot;Sarah&quot;, &quot;followed_by&quot;: [&quot;Carl&quot;, &quot;Paul&quot;]},
  {&quot;name&quot;: &quot;Carol&quot;, &quot;followed_by&quot;: [&quot;Helen&quot;, &quot;Sarah&quot;]},
  {&quot;name&quot;: &quot;Helen&quot;, &quot;followed_by&quot;: [&quot;Paul&quot;]},
]);
</code></pre>
<h2 id="aggregation-pipeline-8"><a class="header" href="#aggregation-pipeline-8">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // For each social network user, graph traverse their 'followed_by' list of people
  {&quot;$graphLookup&quot;: {
    &quot;from&quot;: &quot;users&quot;,
    &quot;startWith&quot;: &quot;$followed_by&quot;,
    &quot;connectFromField&quot;: &quot;followed_by&quot;,
    &quot;connectToField&quot;: &quot;name&quot;,
    &quot;depthField&quot;: &quot;depth&quot;,
    &quot;as&quot;: &quot;extended_network&quot;,
  }},

  // Add new accumulating fields
  {&quot;$set&quot;: {
    // Count the extended connection reach
    &quot;network_reach&quot;: {
      &quot;$size&quot;: &quot;$extended_network&quot;
    },

    // Gather the list of the extended connections' names
    &quot;extended_connections&quot;: {
      &quot;$map&quot;: {
        &quot;input&quot;: &quot;$extended_network&quot;,
        &quot;as&quot;: &quot;connection&quot;,
        &quot;in&quot;: &quot;$$connection.name&quot;,
      }
    },    
  }},
    
  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
    &quot;followed_by&quot;,
    &quot;extended_network&quot;,
  ]},   
  
  // Sort by person with greatest network reach first, in descending order
  {&quot;$sort&quot;: {
    &quot;network_reach&quot;: -1,
  }},   
];
</code></pre>
<h2 id="execution-8"><a class="header" href="#execution-8">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.users.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.users.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-8"><a class="header" href="#expected-results-8">Expected Results</a></h2>
<p>Ten documents should be returned, corresponding to the original ten source social network users, with each one including a count of the user's <em>network reach</em>, and the names of their <em>extended connections</em>, sorted by the user with the most extensive network reach first, as shown below:</p>
<pre><code class="language-javascript">[
  {
    name: 'Carol',
    network_reach: 8,
    extended_connections: [ 'David', 'Toni', 'Fiona', 'Sarah', 'Helen', 'Carl', 'Paul',  'Janet' ]
  },
  {
    name: 'Sarah',
    network_reach: 6,
    extended_connections: [ 'David', 'Toni', 'Fiona', 'Carl', 'Paul', 'Janet' ]
  },
  {
    name: 'Carl',
    network_reach: 5,
    extended_connections: [ 'David', 'Toni', 'Fiona', 'Paul', 'Janet' ]
  },
  {
    name: 'Fiona',
    network_reach: 4,
    extended_connections: [ 'David', 'Toni', 'Paul', 'Janet' ]
  },
  {
    name: 'David',
    network_reach: 3,
    extended_connections: [ 'Toni', 'Paul', 'Janet' ]
  },
  {
    name: 'Bob',
    network_reach: 3,
    extended_connections: [ 'Toni', 'Paul', 'Janet' ]
  },
  {
    name: 'Janet',
    network_reach: 2,
    extended_connections: [ 'Toni', 'Paul' ]
  },
  {
    name: 'Toni',
    network_reach: 1, 
    extended_connections: [ 'Paul']
  },
  { 
    name: 'Helen',
    network_reach: 1, 
    extended_connections: [ 'Paul' ] 
  },
  { name: 'Paul', 
    network_reach: 0, 
    extended_connections: [] 
  }
]
</code></pre>
<h2 id="observations-8"><a class="header" href="#observations-8">Observations</a></h2>
<ul>
<li>
<p><strong>Following Graphs.</strong> The <code>$graphLookup</code> stage helps you traverse relationships between records, looking for patterns that aren't necessarily evident from looking at each record in isolation. In this example, by looking at <em>Paul's</em> record in isolation, it is evident that <em>Paul</em> has no <em>friends</em> and thus has the lowest network reach. However, it is not obvious that <em>Carol</em> has the greatest network reach just by looking at the number of people <em>Carol</em> is directly followed by, which is two. <em>David</em>, for example, is followed by three people (one more than <em>Carol</em>). However, the executed aggregation pipeline can deduce that <em>Carol</em> has the most extensive network reach.</p>
</li>
<li>
<p><strong>Index Use.</strong> The <code>$graphLookup</code> stage can leverage the index on the field <code>name</code> for each of its <code>connectToField</code> hops.</p>
</li>
</ul>
<h1 id="intricate-examples"><a class="header" href="#intricate-examples">Intricate Examples</a></h1>
<p>This section provides examples for using the Aggregation Framework to solve data manipulation challenges that aren't necessarily common to most business requirements but help demonstrate what is possible when a more creative and elaborate solution is required.</p>
<h1 id="incremental-analytics"><a class="header" href="#incremental-analytics">Incremental Analytics</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-9"><a class="header" href="#scenario-9">Scenario</a></h2>
<p>You have a set of <em>shop orders</em> accumulated over many years, with the retail channel adding new order records continuously to the <em>orders</em> collection throughout each trading day. You want to frequently generate a summary report so management can understand the state of the business and react to changing business trends. Over the years, it takes increasingly longer to generate the report of all daily sums and averages because there is increasingly more days' worth of data to process. From now on, to address this problem, you will only generate each new day's summary analysis at the end of the day and store it in a different collection which accumulates the daily summary records over time.</p>
<p>Unlike most examples in this book, the aggregation pipeline writes its output to a collection rather than streaming the results back to the calling application.</p>
<h2 id="sample-data-population-9"><a class="header" href="#sample-data-population-9">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then add 9 documents to the <code>orders</code> collection representing 5 orders for 01-Feb-2021 and 4 orders for 02-Feb-2021:</p>
<pre><code class="language-javascript">use book-incremental-analytics;
db.dropDatabase();

// Create index for a daily_orders_summary collection
db.daily_orders_summary.createIndex({&quot;day&quot;: 1}, {&quot;unique&quot;: true});

// Create index for a orders collection
db.orders.createIndex({&quot;orderdate&quot;: 1});

// Insert records into the orders collection
// (5 orders for 1st Feb, 4 orders for 2nd Feb)
db.orders.insertMany([
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T08:35:52Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;231.43&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T09:32:07Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;99.99&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T08:25:37Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;63.13&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T19:13:32Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;2.01&quot;),
  },  
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T22:56:53Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;187.99&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-02T23:04:48Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;4.59&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-02T08:55:46Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;48.50&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-02T07:49:32Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;1024.89&quot;),
  },
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-02T13:49:44Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;102.24&quot;),
  },
]);

</code></pre>
<h2 id="aggregation-pipeline-9"><a class="header" href="#aggregation-pipeline-9">Aggregation Pipeline</a></h2>
<p>Define a function to create a pipeline, but with the start and end date parameterised, ready to be used to perform the aggregation multiple times, for different days:</p>
<pre><code class="language-javascript">function getDayAggPipeline(startDay, endDay) {
  return [
    // Match orders for one day only
    {&quot;$match&quot;: {
      &quot;orderdate&quot;: {
        &quot;$gte&quot;: ISODate(startDay),
        &quot;$lt&quot;: ISODate(endDay),
      }
    }},
    
    // Group all orders together into one summary record for the day
    {&quot;$group&quot;: {
      &quot;_id&quot;: null,
      &quot;date_parts&quot;: {&quot;$first&quot;: {&quot;$dateToParts&quot;: {&quot;date&quot;: &quot;$orderdate&quot;}}},
      &quot;total_value&quot;: {&quot;$sum&quot;: &quot;$value&quot;},
      &quot;total_orders&quot;: {&quot;$sum&quot;: 1},
    }},
      
    // Get date parts from 1 order (need year+month+day, for UTC)
    {&quot;$set&quot;: {
      &quot;day&quot;: {
        &quot;$dateFromParts&quot;: {
          &quot;year&quot;: &quot;$date_parts.year&quot;, 
          &quot;month&quot;: &quot;$date_parts.month&quot;,
          &quot;day&quot;:&quot;$date_parts.day&quot;
       }
     },
    }},
        
    // Omit unwanted field
    {&quot;$unset&quot;: [
      &quot;_id&quot;,
      &quot;date_parts&quot;,
    ]},
    
    // Add day summary to summary collection (overwrite if already exists)
    {&quot;$merge&quot;: {
      &quot;into&quot;: &quot;daily_orders_summary&quot;,
      &quot;on&quot;: &quot;day&quot;,
      &quot;whenMatched&quot;: &quot;replace&quot;,
      &quot;whenNotMatched&quot;: &quot;insert&quot;
    }},   
  ];
}
</code></pre>
<h2 id="execution-9"><a class="header" href="#execution-9">Execution</a></h2>
<p>For 01-Feb-2021 orders only, build the pipeline and execute the aggregation: </p>
<pre><code class="language-javascript">// Get the pipeline for the 1st day
var pipeline = getDayAggPipeline(&quot;2021-02-01T00:00:00Z&quot;, &quot;2021-02-02T00:00:00Z&quot;);

// Run aggregation for 01-Feb-2021 orders &amp; put result in summary collection
db.orders.aggregate(pipeline);

// View the summary collection content (should be 1 record only)
db.daily_orders_summary.find()
</code></pre>
<p>From the results, you can see that only a single order summary has been generated, for 01-Feb-2021, containing the total value and number of orders for that day.</p>
<p>Now for the next day only (for 02-Feb-2021 orders), build the pipeline and execute the aggregation: </p>
<pre><code class="language-javascript">// Get the pipeline for the 2nd day
var pipeline = getDayAggPipeline(&quot;2021-02-02T00:00:00Z&quot;, &quot;2021-02-03T00:00:00Z&quot;);

// Run aggregation for 02-Feb-2021 orders &amp; put result in summary collection
db.orders.aggregate(pipeline);

// View the summary collection content (should be 2 record now)
db.daily_orders_summary.find()
</code></pre>
<p>From the results, you can see that order summaries exist for both days.</p>
<p>To simulate the organisation's occasional need to correct an old order retrospectively, go back and add a new 'high value' order for the first day. Then re-run the aggregation for the first day only (01-Feb-2021) to show that you can safely and correctly recalculate the summary for just one day:</p>
<pre><code class="language-javascript">// Retrospectively add an order to an older day (01-Feb-2021)
db.orders.insertOne(
  {
    &quot;orderdate&quot;: ISODate(&quot;2021-02-01T09:32:07Z&quot;),
    &quot;value&quot;: NumberDecimal(&quot;11111.11&quot;),
  },
)

// Get the pipeline for the 1st day again
var pipeline = getDayAggPipeline(&quot;2021-02-01T00:00:00Z&quot;, &quot;2021-02-02T00:00:00Z&quot;);

// Re-run aggregation for 01-Feb-2021 overwriting 1st record in summary collections
db.orders.aggregate(pipeline);

// View the summary collection content (should still be 2 records but 1st changed)
db.daily_orders_summary.find()
</code></pre>
<p>From the results, you can see that two order summaries still exist, one for each of the two trading days, but the total value and order count for the first day has changed.</p>
<p>For completeness, also view the explain plan for the aggregation pipeline:</p>
<pre><code class="language-javascript">db.products.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-9"><a class="header" href="#expected-results-9">Expected Results</a></h2>
<p>The content of the <code>daily_orders_summary</code> collection after running the aggregation for just the 1st day should be similar to below:</p>
<pre><code class="language-javascript">[
  {
    _id: ObjectId('6062102e7eeb772e6ca96bc7'),
    total_value: NumberDecimal('584.55'),
    total_orders: 5,
    day: ISODate('2021-02-01T00:00:00.000Z')
  }
]
</code></pre>
<p>The content of the <code>daily_orders_summary</code> collection after running the aggregation for the 2nd day should be similar to below:</p>
<pre><code class="language-javascript">[
  {
    _id: ObjectId('6062102e7eeb772e6ca96bc7'),
    total_value: NumberDecimal('584.55'),
    total_orders: 5,
    day: ISODate('2021-02-01T00:00:00.000Z')
  },
  {
    _id: ObjectId('606210377eeb772e6ca96bcc'),
    total_value: NumberDecimal('1180.22'),
    total_orders: 4,
    day: ISODate('2021-02-02T00:00:00.000Z')
  }
]
</code></pre>
<p>After re-running the aggregation for the 1st day following the addition of the missed order, the content of the <code>daily_orders_summary</code> collection should be similar to below (notice the first record now shows a value of one greater than before for <code>total_orders</code>, and for <code>total_value</code> the value is now significantly higher):</p>
<pre><code class="language-javascript">[
  {
    _id: ObjectId('6062102e7eeb772e6ca96bc7'),
    total_value: NumberDecimal('11695.66'),
    total_orders: 6,
    day: ISODate('2021-02-01T00:00:00.000Z')
  },
  {
    _id: ObjectId('606210377eeb772e6ca96bcc'),
    total_value: NumberDecimal('1180.22'),
    total_orders: 4,
    day: ISODate('2021-02-02T00:00:00.000Z')
  }
]
</code></pre>
<h2 id="observations-9"><a class="header" href="#observations-9">Observations</a></h2>
<ul>
<li>
<p><strong>Merging Results.</strong> The pipeline uses a <code>$merge</code> stage to instruct the aggregation engine to write the output to a collection rather than returning a stream of results. In this example, with the options you provide to <code>$merge</code>, the aggregation inserts a new record in the destination collection if a matching one doesn't already exist. If a matching record already exists, it replaces the previous version.</p>
</li>
<li>
<p><strong>Incremental Updates.</strong> The example illustrates just two days of shop orders, albeit with only a few orders, to keep the example simple. At the end of each new trading day, you run the aggregation pipeline to generate the current day's summary only. Even after the source collection has increased in size over many years, the time it takes you to bring the summary collection up to date again stays constant. In a real-world scenario, the business might expose a graphical chart showing the changing daily orders trend over the last rolling year. This charting dashboard is not burdened by the cost of periodically regenerating values for all days in the year. There could be hundreds of thousands of orders received per day for real-world retailers, especially large ones. A day's summary may take many seconds to generate in that situation. Without an <em>incremental analytics</em> approach, if you need to generate a year's worth of daily summaries every time, it would take hours to refresh the business dashboard.</p>
</li>
<li>
<p><strong>Idempotency.</strong> If a retailer is aggregating tens of thousands of orders per day, then during end-of-day processing, it may choose to generate 24 hourly summary records rather than a single daily record.  This provides the business with finer granularity to understand trends better. As with any software process, when generating hourly results into the summary collection, there is the risk of not fully completing if a system failure occurs. If an in-flight aggregation terminates abnormally, it may not have written all 24 summary collection records. The failure leaves the summary collection in an indeterminate and incomplete state for one of its days. However, this isn't a problem because of the way the aggregation pipeline uses the <code>$merge</code> stage. When an aggregation fails to complete, it can just be re-run. When re-run, it will regenerate all the results for the day, replacing existing summary records and filling in the missing ones. The aggregation pipeline is idempotent, and you can run it repeatedly without damaging the summary collection. The overall solution is self-healing and naturally tolerant of inadvertently aborted aggregation jobs.</p>
</li>
<li>
<p><strong>Retrospective Changes.</strong> Sometimes, an organisation may need to go back and correct records from the past, as illustrated in this example. For instance, a bank may need to fix a past payment record due to a settlement issue that only comes to light weeks later. With the approach used in this example, it is straightforward to re-execute the aggregation pipeline for a prior date, using the updated historical data. This will correctly update the specific day's summary data only, to reflect the business's current state.</p>
</li>
</ul>
<h1 id="mask-sensitive-fields"><a class="header" href="#mask-sensitive-fields">Mask Sensitive Fields</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.4    <em>(due to use of <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/rand/">$rand</a> operator)</em></p>
<h2 id="scenario-10"><a class="header" href="#scenario-10">Scenario</a></h2>
<p>You want to perform irreversible masking on the sensitive fields of a collection of <em>credit card payments</em>, ready to provide the output data set to a 3rd party for analysis, without exposing sensitive information to the 3rd party. The specific changes that you need to make to the payments' fields are:</p>
<ul>
<li>Partially obfuscate the carder holder's name</li>
<li>Obfuscate the first 12 digits of the card's number, retaining only the final 4 digits</li>
<li>Adjust the card's expiry date-time by adding or subtracting a random amount up to a maximum of 30 days (~1 month)</li>
<li>Replace the card's 3 digit security code with a random set of 3 digits</li>
<li>Adjust the transaction's amount by adding or subtracting a random amount up to a maximum of 10% of the original amount</li>
<li>Change the <code>reported</code> field's boolean value to the opposite value for roughly 20% of the records</li>
<li>If the embedded <code>customer_info</code> sub-document's <code>category</code> field is set to <em>RESTRICTED</em>, exclude the whole <code>customer_info</code> sub-document</li>
</ul>
<h2 id="sample-data-population-10"><a class="header" href="#sample-data-population-10">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <code>payments</code> collection with 2 credit card payment documents, containing sensitive data:</p>
<pre><code class="language-javascript">use book-mask-sensitive-fields;
db.dropDatabase();

// Insert records into the payments collection
db.payments.insertMany([
    {
        &quot;card_name&quot;: &quot;Mrs. Jane A. Doe&quot;,
        &quot;card_num&quot;: &quot;1234567890123456&quot;,
        &quot;card_expiry&quot;: ISODate(&quot;2023-08-31T23:59:59Z&quot;),
        &quot;card_sec_code&quot;: &quot;123&quot;,
        &quot;card_type&quot;: &quot;CREDIT&quot;,        
        &quot;transaction_id&quot;: &quot;eb1bd77836e8713656d9bf2debba8900&quot;,
        &quot;transaction_date&quot;: ISODate(&quot;2021-01-13T09:32:07Z&quot;),
        &quot;transaction_amount&quot;: NumberDecimal(&quot;501.98&quot;),
        &quot;reported&quot;: false,
        &quot;customer_info&quot;: {
            &quot;category&quot;: &quot;RESTRICTED&quot;,
            &quot;rating&quot;: 89,
            &quot;risk&quot;: 3,
        },
    },
    {
        &quot;card_name&quot;: &quot;Jim Smith&quot;,
        &quot;card_num&quot;: &quot;9876543210987654&quot;,
        &quot;card_expiry&quot;: ISODate(&quot;2022-12-31T23:59:59Z&quot;),
        &quot;card_sec_code&quot;: &quot;987&quot;,
        &quot;card_type&quot;: &quot;DEBIT&quot;,        
        &quot;transaction_id&quot;: &quot;634c416a6fbcf060bb0ba90c4ad94f60&quot;,
        &quot;transaction_date&quot;: ISODate(&quot;2020-11-24T19:25:57Z&quot;),
        &quot;transaction_amount&quot;: NumberDecimal(&quot;64.01&quot;),
        &quot;reported&quot;: true,
        &quot;customer_info&quot;: {
            &quot;category&quot;: &quot;NORMAL&quot;,
            &quot;rating&quot;: 78,
            &quot;risk&quot;: 55,
        },
    },
]);
</code></pre>
<h2 id="aggregation-pipeline-10"><a class="header" href="#aggregation-pipeline-10">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Replace a subset of fields with new values
  {&quot;$set&quot;: {
    // Extract the last word from the name , eg: 'Doe' from 'Mrs. Jane A. Doe'
    &quot;card_name&quot;: {&quot;$regexFind&quot;: {&quot;input&quot;: &quot;$card_name&quot;, &quot;regex&quot;: /(\S+)$/}},
          
    // Mask card num 1st part retaining last 4 chars, eg: '1234567890123456' -&gt; 'XXXXXXXXXXXX3456'
    &quot;card_num&quot;: {&quot;$concat&quot;: [
                  &quot;XXXXXXXXXXXX&quot;,
                  {&quot;$substrCP&quot;: [&quot;$card_num&quot;, 12, 4]},
                ]},                     

    // Add/subtract a random time amount of a maximum of 30 days (~1 month) each-way
    &quot;card_expiry&quot;: {&quot;$add&quot;: [
                     &quot;$card_expiry&quot;,
                     {&quot;$floor&quot;: {&quot;$multiply&quot;: [{&quot;$subtract&quot;: [{&quot;$rand&quot;: {}}, 0.5]}, 2*30*24*60*60*1000]}},
                   ]},                     

    // Replace each digit with random digit, eg: '133' -&gt; '472'
    &quot;card_sec_code&quot;: {&quot;$concat&quot;: [
                       {&quot;$toString&quot;: {&quot;$floor&quot;: {&quot;$multiply&quot;: [{&quot;$rand&quot;: {}}, 10]}}},
                       {&quot;$toString&quot;: {&quot;$floor&quot;: {&quot;$multiply&quot;: [{&quot;$rand&quot;: {}}, 10]}}},
                       {&quot;$toString&quot;: {&quot;$floor&quot;: {&quot;$multiply&quot;: [{&quot;$rand&quot;: {}}, 10]}}},
                     ]},
                     
    // Add/subtract a random percent of the amount's value up to 10% maximum each-way
    &quot;transaction_amount&quot;: {&quot;$add&quot;: [
                            &quot;$transaction_amount&quot;,
                            {&quot;$multiply&quot;: [{&quot;$subtract&quot;: [{&quot;$rand&quot;: {}}, 0.5]}, 0.2, &quot;$transaction_amount&quot;]},
                          ]},
                          
    // Retain field's bool value 80% of time on average, setting to the opposite value 20% of time
    &quot;reported&quot;: {&quot;$cond&quot;: {
                   &quot;if&quot;:   {&quot;$lte&quot;: [{&quot;$rand&quot;: {}}, 0.8]},
                   &quot;then&quot;: &quot;$reported&quot;,
                   &quot;else&quot;: {&quot;$not&quot;: [&quot;$reported&quot;]},
                }},      

    // Exclude sub-doc if the sub-doc's category field's value is 'RESTRICTED'
    &quot;customer_info&quot;: {&quot;$cond&quot;: {
                        &quot;if&quot;:   {&quot;$eq&quot;: [&quot;$customer_info.category&quot;, &quot;RESTRICTED&quot;]}, 
                        &quot;then&quot;: &quot;$$REMOVE&quot;,     
                        &quot;else&quot;: &quot;$customer_info&quot;,
                     }},                                         
                
    // Mark _id field to excluded from results
    &quot;_id&quot;: &quot;$$REMOVE&quot;,                
  }},
  
  // Take regex matched last word from the card name and prefix it with hardcoded value
  {&quot;$set&quot;: {
    &quot;card_name&quot;: {&quot;$concat&quot;: [&quot;Mx. Xxx &quot;, {&quot;$ifNull&quot;: [&quot;$card_name.match&quot;, &quot;Anonymous&quot;]}]},                       
  }},
];
</code></pre>
<h2 id="execution-10"><a class="header" href="#execution-10">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.payments.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.payments.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-10"><a class="header" href="#expected-results-10">Expected Results</a></h2>
<p>Two documents should be returned, corresponding to the original two source documents, but this time with many of their fields redacted and obfuscated, plus the <code>customer_info</code> embedded document omitted for one record due to it having been marked as <code>RESTRICTED</code>, as shown below:</p>
<pre><code class="language-javascript">[
  {
    card_name: 'Mx. Xxx Doe',
    card_num: 'XXXXXXXXXXXX3456',
    card_expiry: ISODate('2023-08-31T23:29:46.460Z'),
    card_sec_code: '295',
    card_type: 'CREDIT',
    transaction_id: 'eb1bd77836e8713656d9bf2debba8900',
    transaction_date: ISODate('2021-01-13T09:32:07.000Z'),
    transaction_amount: NumberDecimal('492.4016988351474881660000000000000'),
    reported: false
  },
  {
    card_name: 'Mx. Xxx Smith',
    card_num: 'XXXXXXXXXXXX7654',
    card_expiry: ISODate('2023-01-01T00:34:49.330Z'),
    card_sec_code: '437',
    card_type: 'DEBIT',
    transaction_id: '634c416a6fbcf060bb0ba90c4ad94f60',
    transaction_date: ISODate('2020-11-24T19:25:57.000Z'),
    transaction_amount: NumberDecimal('58.36081337486762223600000000000000'),
    reported: false,
    customer_info: { category: 'NORMAL', rating: 78, risk: 55 }
  }
]
</code></pre>
<h2 id="observations-10"><a class="header" href="#observations-10">Observations</a></h2>
<ul>
<li>
<p><strong>Targeted Redaction.</strong> The pipeline uses a <code>$cond</code> operator to return the <code>$$REMOVE</code> marker variable if the <code>category</code> field is equal to <code>RESTRICTED</code>. This informs the aggregation engine to exclude the whole <code>customer_info</code> sub-document from the stage's output for the record. Alternatively, the pipeline could have used a <code>$redact</code> stage to achieve the same. However, <code>$redact</code> typically has to perform more processing work due to needing to check every field in the document. Hence, if a pipeline is only to redact out one specific sub-document, use the approach outlined in this example.</p>
</li>
<li>
<p><strong>Regular Expression.</strong> For masking the <code>card_name</code> field, a regular expression operator is used to extract the last word of the field's original value. <code>$regexFind</code> returns metadata into the stage's output records, indicating if the match succeeded and what the matched value is. Therefore, an additional <code>$set</code> stage is required later in the pipeline to extract the actual matched word from this metadata and prefix it with some hard-coded text.</p>
</li>
<li>
<p><strong>Unset Alternative.</strong> If this example was consistent with the other examples in this book, the pipeline would include an additional <code>$unset</code> stage to exclude the <code>_id</code> field. However, in this case, chiefly to show there is another way, the pipeline marks the <code>_id</code> field for exclusion in the <code>$set</code> stage by being assigned the <code>$$REMOVE</code> variable.</p>
</li>
<li>
<p><strong>Meaningful Insight.</strong> Even though the pipeline is irreversibly obfuscating fields, it doesn't mean that the masked data is useless for performing analytics to gain insight. The pipeline masks some fields by fluctuating the original values by a small but limited random percentage (e.g. <code>card_expiry</code>, <code>transaction_amount</code>), rather than replacing them with completely random values (e.g. <code>card_sec_code</code>). In such cases, if the input data set is sufficiently large, then minor variances will be equalled out. For the fields that are only varied slightly, users can derive similar trends and patterns from analysing the masked data as they would the original data.</p>
</li>
<li>
<p><strong>Further Reading.</strong> This example is based on the output of two blog posts: 1) <a href="https://pauldone.blogspot.com/2021/02/mongdb-data-masking.html">MongoDB Irreversible Data Masking</a>, and 2) <a href="https://pauldone.blogspot.com/2021/02/mongdb-reversible-data-masking.html">MongoDB Reversible Data Masking</a>.</p>
</li>
</ul>
<h1 id="convert-incomplete-date-strings"><a class="header" href="#convert-incomplete-date-strings">Convert Incomplete Date Strings</a></h1>
<p><strong>Minimum MongoDB Version:</strong> 4.2</p>
<h2 id="scenario-11"><a class="header" href="#scenario-11">Scenario</a></h2>
<p>An application is ingesting <em>payment</em> documents into a MongoDB collection where each document's <em>payment date</em> field contains a string looking vaguely like a date-time, such as <code>&quot;01-JAN-20 01.01.01.123000000&quot;</code>. You want to convert each <em>payment date</em> into a valid BSON date type when aggregating the payments. However, the payment date fields do not contain all the information required for you to determine the exact date-time accurately. Therefore you cannot use just the MongoDB's <a href="https://docs.mongodb.com/manual/reference/operator/aggregation/#date-expression-operators">Date Expression Operators</a> directly to perform the text-to-date conversion. Each of these text fields is missing the following information:</p>
<ul>
<li>The specific <strong>century</strong> (1900s?, 2000s, other?)</li>
<li>The specific <strong>time-zone</strong> (GMT?, IST?, PST?, other?) </li>
<li>The specific <strong>language</strong> that the three-letter month abbreviation represents (is 'JAN' in French? in English? other?)</li>
</ul>
<p>You subsequently learn that all the payment records are for the <strong>21st century</strong> only, the time-zone used when ingesting the data is <strong>UTC</strong>, and the language used is <strong>English</strong>. Armed with this information, you build an aggregation pipeline to transform these text fields into date fields.</p>
<h2 id="sample-data-population-11"><a class="header" href="#sample-data-population-11">Sample Data Population</a></h2>
<p>Drop any old version of the database (if it exists) and then populate a new <em>payments</em> collection with 12 sample payments documents, providing coverage across all 12 months for the year 2020, with random time elements.</p>
<pre><code class="language-javascript">use book-convert-incomplete-dates;
db.dropDatabase();

// Insert records into the payments collection
db.payments.insertMany([
  {&quot;account&quot;: &quot;010101&quot;, &quot;payment_date&quot;: &quot;01-JAN-20 01.01.01.123000000&quot;, &quot;amount&quot;: 1.01},
  {&quot;account&quot;: &quot;020202&quot;, &quot;payment_date&quot;: &quot;02-FEB-20 02.02.02.456000000&quot;, &quot;amount&quot;: 2.02},
  {&quot;account&quot;: &quot;030303&quot;, &quot;payment_date&quot;: &quot;03-MAR-20 03.03.03.789000000&quot;, &quot;amount&quot;: 3.03},
  {&quot;account&quot;: &quot;040404&quot;, &quot;payment_date&quot;: &quot;04-APR-20 04.04.04.012000000&quot;, &quot;amount&quot;: 4.04},
  {&quot;account&quot;: &quot;050505&quot;, &quot;payment_date&quot;: &quot;05-MAY-20 05.05.05.345000000&quot;, &quot;amount&quot;: 5.05},
  {&quot;account&quot;: &quot;060606&quot;, &quot;payment_date&quot;: &quot;06-JUN-20 06.06.06.678000000&quot;, &quot;amount&quot;: 6.06},
  {&quot;account&quot;: &quot;070707&quot;, &quot;payment_date&quot;: &quot;07-JUL-20 07.07.07.901000000&quot;, &quot;amount&quot;: 7.07},
  {&quot;account&quot;: &quot;080808&quot;, &quot;payment_date&quot;: &quot;08-AUG-20 08.08.08.234000000&quot;, &quot;amount&quot;: 8.08},
  {&quot;account&quot;: &quot;090909&quot;, &quot;payment_date&quot;: &quot;09-SEP-20 09.09.09.567000000&quot;, &quot;amount&quot;: 9.09},
  {&quot;account&quot;: &quot;101010&quot;, &quot;payment_date&quot;: &quot;10-OCT-20 10.10.10.890000000&quot;, &quot;amount&quot;: 10.10},
  {&quot;account&quot;: &quot;111111&quot;, &quot;payment_date&quot;: &quot;11-NOV-20 11.11.11.111000000&quot;, &quot;amount&quot;: 11.11},
  {&quot;account&quot;: &quot;121212&quot;, &quot;payment_date&quot;: &quot;12-DEC-20 12.12.12.999000000&quot;, &quot;amount&quot;: 12.12}
]);
</code></pre>
<h2 id="aggregation-pipeline-11"><a class="header" href="#aggregation-pipeline-11">Aggregation Pipeline</a></h2>
<p>Define a single pipeline ready to perform the aggregation:</p>
<pre><code class="language-javascript">var pipeline = [
  // Change field from a string to a date, filling in the missing gaps
  {&quot;$set&quot;: {
    &quot;payment_date&quot;: {    
      &quot;$let&quot;: {
        &quot;vars&quot;: {
          &quot;txt&quot;: &quot;$payment_date&quot;,  // Assign &quot;payment_date&quot; field to variable &quot;txt&quot;
        },
        &quot;in&quot;: { 
          &quot;$dateFromString&quot;: {&quot;format&quot;: &quot;%d-%m-%Y %H.%M.%S.%L&quot;, &quot;dateString&quot;:
            {&quot;$concat&quot;: [
              {&quot;$substrCP&quot;: [&quot;$$txt&quot;, 0, 3]},  // Use 1st 3 chars in string
              {&quot;$switch&quot;: {&quot;branches&quot;: [  // Replace month 3 chars with month number
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;JAN&quot;]}, &quot;then&quot;: &quot;01&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;FEB&quot;]}, &quot;then&quot;: &quot;02&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;MAR&quot;]}, &quot;then&quot;: &quot;03&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;APR&quot;]}, &quot;then&quot;: &quot;04&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;MAY&quot;]}, &quot;then&quot;: &quot;05&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;JUN&quot;]}, &quot;then&quot;: &quot;06&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;JUL&quot;]}, &quot;then&quot;: &quot;07&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;AUG&quot;]}, &quot;then&quot;: &quot;08&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;SEP&quot;]}, &quot;then&quot;: &quot;09&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;OCT&quot;]}, &quot;then&quot;: &quot;10&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;NOV&quot;]}, &quot;then&quot;: &quot;11&quot;},
                {&quot;case&quot;: {&quot;$eq&quot;: [{&quot;$substrCP&quot;: [&quot;$$txt&quot;, 3, 3]}, &quot;DEC&quot;]}, &quot;then&quot;: &quot;12&quot;},
               ], &quot;default&quot;: &quot;ERROR&quot;}},
              &quot;-20&quot;,  // Add hyphen + hardcoded century 2 digits
              {&quot;$substrCP&quot;: [&quot;$$txt&quot;, 7, 15]}  // Use remaining 3 millis (ignore last 6 nanosecs)
            ]
          }}                  
        }
      }        
    },             
  }},

  // Omit unwanted fields
  {&quot;$unset&quot;: [
    &quot;_id&quot;,
  ]},         
];
</code></pre>
<h2 id="execution-11"><a class="header" href="#execution-11">Execution</a></h2>
<p>Execute the aggregation using the defined pipeline and also view its explain plan:</p>
<pre><code class="language-javascript">db.payments.aggregate(pipeline);
</code></pre>
<pre><code class="language-javascript">db.payments.explain(&quot;executionStats&quot;).aggregate(pipeline);
</code></pre>
<h2 id="expected-results-11"><a class="header" href="#expected-results-11">Expected Results</a></h2>
<p>Twelve documents should be returned, corresponding to the original twelve source documents, but this time with the <code>payment_date</code> field converted from text values to proper date typed values, as shown below:</p>
<pre><code class="language-javascript">[
  {
    account: '010101',
    payment_date: ISODate('2020-01-01T01:01:01.123Z'),
    amount: 1.01
  },
  {
    account: '020202',
    payment_date: ISODate('2020-02-02T02:02:02.456Z'),
    amount: 2.02
  },
  {
    account: '030303',
    payment_date: ISODate('2020-03-03T03:03:03.789Z'),
    amount: 3.03
  },
  {
    account: '040404',
    payment_date: ISODate('2020-04-04T04:04:04.012Z'),
    amount: 4.04
  },
  {
    account: '050505',
    payment_date: ISODate('2020-05-05T05:05:05.345Z'),
    amount: 5.05
  },
  {
    account: '060606',
    payment_date: ISODate('2020-06-06T06:06:06.678Z'),
    amount: 6.06
  },
  {
    account: '070707',
    payment_date: ISODate('2020-07-07T07:07:07.901Z'),
    amount: 7.07
  },
  {
    account: '080808',
    payment_date: ISODate('2020-08-08T08:08:08.234Z'),
    amount: 8.08
  },
  {
    account: '090909',
    payment_date: ISODate('2020-09-09T09:09:09.567Z'),
    amount: 9.09
  },
  {
    account: '101010',
    payment_date: ISODate('2020-10-10T10:10:10.890Z'),
    amount: 10.1
  },
  {
    account: '111111',
    payment_date: ISODate('2020-11-11T11:11:11.111Z'),
    amount: 11.11
  },
  {
    account: '121212',
    payment_date: ISODate('2020-12-12T12:12:12.999Z'),
    amount: 12.12
  }
]
</code></pre>
<h2 id="observations-11"><a class="header" href="#observations-11">Observations</a></h2>
<ul>
<li>
<p><strong>Concatenation Explanation.</strong> In this pipeline, the text fields (e.g. <code>'12-DEC-20 12.12.12.999000000'</code>) are each converted to date fields (e.g. <code>2020-12-12T12:12:12.999Z</code>). This is achieved by concatenating together the following four example elements before passing them to the <code>$dateFromString</code> operator to convert to a date type:</p>
<ul>
<li><code>'12-'</code> <em>(day of the month from the input string + the hyphen suffix already present in the text)</em></li>
<li><code>'12'</code> <em>(replacing 'DEC')</em></li>
<li><code>'-20'</code> <em>(hard-coded hyphen + hardcoded century)</em></li>
<li><code>'20 12.12.12.999'</code> <em>(the rest of input string apart from the last 6 nanosecond digits)</em></li>
</ul>
</li>
<li>
<p><strong>Further Reading.</strong> This example is based on the output of the blog post: <a href="https://pauldone.blogspot.com/2020/05/aggregation-convert-nasty-date-strings.html">Converting Gnarly Date Strings to Proper Date Types Using a MongoDB Aggregation Pipeline</a>.</p>
</li>
</ul>
<p><img src="./pics/back-cover.png" alt="Practical MongoDB Aggregations book back cover" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
